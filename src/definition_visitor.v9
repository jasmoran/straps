func definition(node)(children, ix, new_child, sub_children, sub_child, data) {
	var children = node_children(var node)
	node_type(var node)

	if (rax == nCLASS) {
		map_new(100)
		var node[32] = rax

		# Get fields
		ll_get(var children, 1)
		var sub_children = node_children(rax)
		var ix = 0
		loop {
			if (var ix == ll_length(var sub_children)) { break }
			var new_child = node_new(nNUMBER, 4, 0)
			node_data(var new_child)
			rbx = var ix
			rbx << 3
			string_from_number(rbx, rax, 1)

			ll_get(var sub_children, var ix)
			var sub_child = rax
			node_data(var sub_child)
			map_set(var node[32], rax, var new_child)
			resolve_type(var sub_child)
			var new_child[40] = rax

			var sub_child[0] = nNONE

			var ix++
		}

		# Remove self from AST
		node_parent(var node)
		var children = node_children(rax)
		ll_fetch_by_data(var children, var node)
		ll_remove_node(var children, rax)

		return
	}

	if (rax == nENUM) {
		var ix = 0
		loop {
			if (var ix == ll_length(var children)) { break }
			var new_child = node_new(nNUMBER, 4, 0)
			node_data(var new_child)
			string_from_number(var ix, rax, 0)

			ll_get(var children, var ix)
			var sub_child = rax
			node_data(var sub_child)
			map_set(global_vars[0], rax, var new_child)

			var sub_child[0] = nSTRING

			var ix++
		}

		return
	}

	if (rax == nFUNCTION) {
		var data = node_data(var node)
		string_length(var data)
		var new_child = node_new(nIDENTIFIER, rax, 0)
		node_data(var new_child)
		string_copy(var data, rax)
		resolve_type(var node)
		var new_child[40] = rax
		map_set(global_vars[0], var data, var new_child)

		map_new(100)
		var node[32] = rax

		# Get arguments
		ll_get(var children, 0)
		var sub_children = node_children(rax)
		var ix = 0
		loop {
			if (var ix == ll_length(var sub_children)) { break }
			rax = var ix
			rax += 2
			rax << 3
			var new_child = new_variable(rax)

			ll_get(var sub_children, var ix)
			var sub_child = rax
			node_data(var sub_child)
			map_set(var node[32], rax, var new_child)
			resolve_type(var sub_child)
			var new_child[40] = rax

			var sub_child[0] = nNONE

			var ix++
		}

		# Get variables
		ll_get(var children, 1)
		var sub_children = node_children(rax)
		var ix = 0
		loop {
			if (var ix == ll_length(var sub_children)) { break }
			nasm("mov rax, -1")
			rax -= var ix
			rax << 3
			var new_child = new_variable(rax)

			ll_get(var sub_children, var ix)
			var sub_child = rax
			node_data(var sub_child)
			map_set(var node[32], rax, var new_child)
			resolve_type(var sub_child)
			var new_child[40] = rax

			var sub_child[0] = nNONE

			var ix++
		}

		return
	}

	if (rax == nGLOBAL) {
		# Get variables
		ll_get(var children, 0)
		var sub_children = node_children(rax)
		var ix = 0
		loop {
			if (var ix == ll_length(var sub_children)) { break }

			ll_get(var sub_children, var ix)
			var sub_child = rax
			var new_child = new_global(var sub_child)
			node_data(var sub_child)
			map_set(global_vars[0], rax, var new_child)
			resolve_type(var sub_child)
			var new_child[40] = rax

			var ix++
		}

		return
	}

	definition_children(var children)

	return
}

func resolve_type(identifier)(children, type) {
	node_class(var identifier)
	var type = node_data(rax)
	map_get(types[0], rax)
	if (rax < 0) {
		string_print(STDERR, "Error: Could not resolve type ")
		string_print(STDERR, var type)
		string_print(STDERR, new_line)

		sys(60,1)
	}
	var identifier[40] = rax

	return rax
}

func new_variable(offset)(node, children, child) {
	var node = node_new(nMEM_ACCESS, 0, 0)
	var children = node_children(var node)

	# Save register
	var child = node_new(nREGISTER, 3, var node)
	node_data(var child)
	string_copy("rbp", rax)
	ll_append(var children, var child)

	# Save offset
	var child = node_new(nNUMBER, 4, var node)
	node_data(var child)
	string_from_number(var offset, rax, 1)
	ll_append(var children, var child)

	return var node
}

func new_global(identifier)(node, children, child) {
	var node = node_new(nMEM_ACCESS, 0, 0)
	var children = node_children(var node)

	# Save name
	ll_append(var children, var identifier)

	# Save offset
	var child = node_new(nNUMBER, 4, var node)
	node_data(var child)
	string_copy("+0", rax)
	ll_append(var children, var child)

	return var node
}

func definition_children(children)(node) {
	var node = ll_first(var children)
	loop {
		if (var node == 0) {
			return
		}
		lln_payload(var node)
		definition(rax)
		var node = lln_next(var node)
	}

	return
}
