~
section .bss
	current_char:	resb	1
	
section .data
	registers:		db		'rax,', 'rdi,', 'rsi,', 'rdx,', 'r10,', 'r8, '
	mov_inst:		db		10, 'mov '
	sys_inst:		db		10, 'syscall', 10

section .text
global main

asm_literal:
	; Read byte from stdin
	mov rax, 0
	mov rdi, 0
	mov rsi, current_char
	mov rdx, 1
	syscall
	
	; Check for EOF
	cmp rax, 0
	je .ret
	
	; Check for end NASM section
	cmp BYTE[current_char], 0x7E ; tilde
	je .ret
	
	; Write byte to stdout
	mov rax, 1
	mov rdi, 1
	mov rsi, current_char
	mov rdx, 1
	syscall
	
	jmp asm_literal
	
.ret:
	ret
	
	

syscall:
	push 0
	
.print_mov:
	; Write move instruction to stdout
	mov rax, 1
	mov rdi, 1
	mov rsi, mov_inst
	mov rdx, 5
	syscall
	
	pop r9
	push r9
	shl r9, 2
	add r9, registers

	; Write register to stdout
	mov rax, 1
	mov rdi, 1
	mov rsi, r9
	mov rdx, 4
	syscall
	
	pop r9
	inc r9
	push r9
	
.print_val:
	; Read byte from stdin
	mov rax, 0
	mov rdi, 0
	mov rsi, current_char
	mov rdx, 1
	syscall
	
	; Check for EOF
	cmp rax, 0
	je .ret
	
	; Check for end of syscall
	cmp BYTE[current_char], 0x2A ; asterisk
	je .close
	
	; Check for comma
	cmp BYTE[current_char], ','
	je .print_mov
	
	; Write byte to stdout
	mov rax, 1
	mov rdi, 1
	mov rsi, current_char
	mov rdx, 1
	syscall
	
	jmp .print_val
	
.close:
	; Write syscall instruction
	mov rax, 1
	mov rdi, 1
	mov rsi, sys_inst
	mov rdx, 9
	syscall
	
.ret:
	pop rax
	ret
	


main:
	; Read byte from stdin
	mov rax, 0
	mov rdi, 0
	mov rsi, current_char
	mov rdx, 1
	syscall
	
	; Check for EOF
	cmp rax, 0
	je .exit
	
	; Check for NASM section
	cmp BYTE[current_char], 0x7E ; tilde
	jne .end_if1
		call asm_literal
		jmp main
	.end_if1:
	
	; Check for syscall
	cmp BYTE[current_char], 0x2A ; asterisk
	jne main
		call syscall
		jmp main
	
	; No man's land
	
.exit:
~
