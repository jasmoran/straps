define k "String"
define v "FunctionNode"
include "src/stdlib/Map.generic"
define k "String"
define v "Node"
include "src/stdlib/Map.generic"

define t "Node"
include "src/stdlib/Array.generic"
define t "FunctionNode"
include "src/stdlib/Array.generic"

enum NodeType {
	nNONE nNASM nSYS nBLOCK nPAREN_LIST nFUNCTION nRETURN nCOMPARISON nIF
	nNEXT nLOOP nBREAK nIDENTIFIER nENUM nCOMMENT nCHARACTER nSTRING nNUMBER
	nINDEX nCALL nOPERATION nMEM_ACCESS nREGISTER nPUSH nPOP nCLASS nFIELD nGLOBAL
	nSTRINGS nBINARYOP nUNARYOP nLIST nFUNCTIONS nVTAB_ACCESS
}

class NodeType() {
	func String toString()(Array<String> a, Number ix) {
		nasm("mov rax, NodeType")
		a = rax
		ix = this
		return a.get(ix)
	}
}

class virtual Node(NodeType type) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)() {}

	func Node toNode()() { return this }
}


class virtual RetNode < Node (Type ret_type) {}
class virtual OpNode < RetNode (Token op) {}


func BinaryOperationNode BinaryOperationNode_new(Token op, Node lhs, Node rhs)() {
	return BinaryOperationNode_new(Type_new(), op, lhs, rhs)
}
func BinaryOperationNode BinaryOperationNode_new(Type ret_type, Token op, Node lhs, Node rhs)() {
	return BinaryOperationNode_new(nBINARYOP, ret_type, op, lhs, rhs)
}

class virtual BinaryOperationNode < OpNode (Node lhs, Node rhs) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.lhs
		n = n.accept(v)
		if (n != 0) this.lhs = n
		n = this.rhs
		n = n.accept(v)
		if (n != 0) this.rhs = n
	}
}


func UnaryOperationNode UnaryOperationNode_new(Token op, Node expr, Boolean left)() {
	return UnaryOperationNode_new(Type_new(), op, expr, left)
}
func UnaryOperationNode UnaryOperationNode_new(Type ret_type, Token op, Node expr, Boolean left)() {
	return UnaryOperationNode_new(nUNARYOP, ret_type, op, expr, left)
}

class virtual UnaryOperationNode < OpNode (Node expr, Boolean left) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.expr
		n = n.accept(v)
		if (n != 0) this.expr = n
	}
}




class virtual StringNode < RetNode (String string) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)() {}
}



func Node ClassNode_new(String name, ListNode fields, ListNode block, Map<String_FunctionNode> vtable, Type parent)(Scope sc) {
	sc = scope
	sc = Scope_new(name, sc)
	return ClassNode_new(nCLASS, name, fields, block, sc, vtable, parent)
}

func Node ClassNode_new(String name, ListNode fields, ListNode block) {
	var Map<String_FunctionNode> vtable = 0
	var parent = Type_new()
	return ClassNode_new(name, fields, block, vtable, parent)
}

class virtual ClassNode < Node (String name, ListNode fields,
								ListNode block, Scope scope, Map<String_FunctionNode> vtable, Type parent) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.fields
		n = n.accept(v)
		if (n != 0) this.fields = n
		n = this.block
		n = n.accept(v)
		if (n != 0) this.block = n
	}
}



func FunctionNode FunctionNode_new(Type ret_type, String name, ListNode args, ListNode vrbls, ListNode block)(Scope sc) {
	sc = scope
	sc = Scope_new(name, sc)
	return FunctionNode_new(nFUNCTION, ret_type, name, args, vrbls, block, sc)
}

class virtual FunctionNode < RetNode (String name, ListNode args, ListNode vrbls, ListNode block, Scope scope) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.args
		n = n.accept(v)
		if (n != 0) this.args = n
		n = this.vrbls
		n = n.accept(v)
		if (n != 0) this.vrbls = n
		n = this.block
		n = n.accept(v)
		if (n != 0) this.block = n
	}

	func FunctionNode shallow_clone()(FunctionNode fn) {
		fn = FunctionNode_new(this.ret_type, this.name, this.args, this.vrbls, ListNode_new(nBLOCK))
		fn.scope = this.scope
		return fn
	}
}



func ListNode ListNode_new(NodeType type)() {
	return ListNode_new(type, LinkedList_new())
}

class virtual ListNode < Node (LinkedList children) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n, LinkedListNode lln) {
		lln = this.children.first
		loop {
			if (lln == 0) { break }
			n = lln.payload
			n = n.accept(v)
			if (n != 0) lln.payload = n
			lln = lln.fwrd
		}
	}

	func ListNode append(Node n)(Any a) {
		a = n
		this.children.append(a)
		return this
	}

	func ListNode prepend(Node n)(Any a) {
		a = n
		this.children.prepend(a)
		return this
	}
}



func Node IfNode_new(Node condition, ListNode block_if)(ListNode l) {
	l = 0
	return IfNode_new(nIF, condition, block_if, l)
}

class virtual IfNode < Node (Node condition, ListNode block_if, ListNode block_else) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.condition
		n = n.accept(v)
		if (n != 0) this.condition = n
		n = this.block_if
		n = n.accept(v)
		if (n != 0) this.block_if = n
		n = this.block_else
		if (n != 0) {
			n = n.accept(v)
			if (n != 0) this.block_else = n
		}
	}
}



func Node LoopNode_new(ListNode block)() {
	return LoopNode_new(nLOOP, block)
}

class virtual LoopNode < Node (ListNode block) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.block
		n = n.accept(v)
		if (n != 0) this.block = n
	}
}



func Node ReturnNode_new(Node expr)() {
	return ReturnNode_new(nRETURN, expr)
}

class virtual ReturnNode < Node (Node expr) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.expr
		n = n.accept(v)
		if (n != 0) this.expr = n
	}
}



func Node EnumNode_new(String name, ListNode values)() {
	return EnumNode_new(nENUM, name, values)
}

class virtual EnumNode < Node (String name, ListNode values) {
	func void accept(Visitor v)() {
		v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		n = this.values
		n = n.accept(v)
		if (n != 0) this.values = n
	}
}
