define k "String"
define v "FunctionNode"
include "src/stdlib/Map.generic"
define k "String"
define v "Node"
include "src/stdlib/Map.generic"

define t "Node"
include "src/stdlib/Array.generic"
define t "FunctionNode"
include "src/stdlib/Array.generic"

define t "Node"
include "src/stdlib/LinkedList.generic"
define t "RetNode"
include "src/stdlib/LinkedList.generic"
define t "FunctionNode"
include "src/stdlib/LinkedList.generic"

define t "Map<String_FunctionNode>"
include "src/stdlib/Option.generic"

define t "LinkedList<Node>"
include "src/stdlib/Option.generic"
define t "LinkedListNode<Node>"
include "src/stdlib/Option.generic"

enum NodeType {
	nNONE nNASM nSYS nBLOCK nPAREN_LIST nFUNCTION nRETURN nCOMPARISON nIF
	nNEXT nLOOP nBREAK nIDENTIFIER nENUM nCOMMENT nCHARACTER nSTRING nNUMBER
	nINDEX nCALL nOPERATION nMEM_ACCESS nREGISTER nPUSH nPOP nCLASS nFIELD nGLOBAL
	nSTRINGS nBINARYOP nUNARYOP nLIST nFUNCTIONS nVTAB_ACCESS nFOR nSTATIC_CLASS
}

class NodeType() {
	func String toString() {
		nasm("mov rax, NodeType")
		var a = rax.to(Array<String>)
		var ix = this.to(Number)
		return a.get(ix)
	}
}

define t "Node"
include "src/stdlib/Option.generic"

class virtual Node(NodeType type, Position position) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)() {}

	func Node clone() {
		return Node_new(this.type, this.position)
	}
}


class virtual RetNode < Node (Type ret_type) {
	func RetNode clone() {
		return RetNode_new(this.type, this.position, this.ret_type)
	}
}

class virtual OpNode < RetNode (Token op) {
	func OpNode clone() {
		return OpNode_new(this.type, this.position, this.ret_type, this.op)
	}
}

func CallNode CallNode_new(Position pos, Node cfunction) {
	var args = LinkedList<RetNode>_new()
	return CallNode_new(pos, cfunction, args)
}

func CallNode CallNode_new(Position pos, Node cfunction, LinkedList<RetNode> args) {
	return CallNode_new(nCALL, pos, Type_new(), cfunction, args)
}

class virtual CallNode < RetNode (Node cfunction, LinkedList<RetNode> args) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_args(Visitor v) {
		for (arg in this.args) {
			var nn = arg.accept(v).unwrap_or(arg).to(RetNode)
			arg_iter.set(nn)
		}
	}

	func void accept_children(Visitor v) {
		this.cfunction = this.cfunction.accept(v).unwrap_or(this.cfunction)
		this.accept_args(v)
	}

	func CallNode clone() {
		return CallNode_new(this.type, this.position, this.ret_type, this.cfunction, this.args)
	}
}


func BinaryOperationNode BinaryOperationNode_new(Position pos, Token op, Node lhs, Node rhs)() {
	return BinaryOperationNode_new(Type_new(), pos, op, lhs, rhs)
}
func BinaryOperationNode BinaryOperationNode_new(Type ret_type, Position pos, Token op, Node lhs, Node rhs)() {
	return BinaryOperationNode_new(nBINARYOP, pos, ret_type, op, lhs, rhs)
}

class virtual BinaryOperationNode < OpNode (Node lhs, Node rhs) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.lhs = this.lhs.accept(v).unwrap_or(this.lhs)
		this.rhs = this.rhs.accept(v).unwrap_or(this.rhs)
	}

	func BinaryOperationNode clone() {
		return BinaryOperationNode_new(this.type, this.position, this.ret_type, this.op, this.lhs, this.rhs)
	}
}


func UnaryOperationNode UnaryOperationNode_new(Position pos, Token op, Node expr, Boolean left)() {
	return UnaryOperationNode_new(pos, Type_new(), op, expr, left)
}
func UnaryOperationNode UnaryOperationNode_new(Position pos, Type ret_type, Token op, Node expr, Boolean left)() {
	return UnaryOperationNode_new(nUNARYOP, pos, ret_type, op, expr, left)
}

class virtual UnaryOperationNode < OpNode (Node expr, Boolean left) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.expr = this.expr.accept(v).unwrap_or(this.expr)
	}

	func UnaryOperationNode clone() {
		return UnaryOperationNode_new(this.type, this.position, this.ret_type, this.op, this.expr, this.left)
	}
}



class virtual StringNode < RetNode (String string) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)() {}

	func StringNode clone() {
		return StringNode_new(this.type, this.position, this.ret_type, this.string)
	}
}

class virtual StaticClassNode < Node (ClassNode klass) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}
}


define t "ClassNode"
include "src/stdlib/Option.generic"

func ClassNode ClassNode_new(Position pos, String name, ListNode fields, ListNode block, Option<Map<String_FunctionNode>> vtable, Option<Type> parent)(Scope sc) {
	sc = Scope_new(name, None<Scope>)
	var ret_type = Type_new(name.clone(6).append("Static"))
	return ClassNode_new(nCLASS, pos, ret_type, name, fields, block, sc, vtable, parent)
}

func ClassNode ClassNode_new(Position pos, String name, ListNode fields, ListNode block) {
	var Option<Map<String_FunctionNode>> vtable = None<Map<String_FunctionNode>>
	return ClassNode_new(pos, name, fields, block, vtable, None<Type>)
}

class virtual ClassNode < RetNode (String name, ListNode fields,
								ListNode block, Scope scope, Option<Map<String_FunctionNode>> vtable, Option<Type> parent) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.fields = this.fields.accept(v).unwrap_or(this.fields)
		this.block = this.block.accept(v).unwrap_or(this.block)
	}

	func ClassNode shallow_clone() {
		return ClassNode_new(this.position, this.name, ListNode_new(nLIST, this.fields.position),
												 ListNode_new(nLIST, this.block.position), this.vtable, this.parent)
	}

	func ClassNode clone() {
		return ClassNode_new(this.type, this.position, this.ret_type, this.name, this.fields, this.block, this.scope, this.vtable, this.parent)
	}
}


define t "FunctionNode"
include "src/stdlib/Option.generic"

func FunctionNode FunctionNode_new(Position pos, Type ret_type, String name, ListNode args, ListNode vrbls, ListNode block)(Scope sc) {
	sc = scope
	sc = Scope_new(name, sc)
	return FunctionNode_new(nFUNCTION, pos, ret_type, name, args, vrbls, block, sc, NullString)
}

class virtual FunctionNode < RetNode (String name, ListNode args, ListNode vrbls, ListNode block, Scope scope, String pure) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.args = this.args.accept(v).unwrap_or(this.args)
		this.vrbls = this.vrbls.accept(v).unwrap_or(this.vrbls)
		this.block = this.block.accept(v).unwrap_or(this.block)
	}

	func FunctionNode shallow_clone()(FunctionNode fn) {
		fn = FunctionNode_new(this.position, this.ret_type, this.name, this.args, this.vrbls, ListNode_new(nBLOCK, this.block.position))
		fn.scope = this.scope
		return fn
	}

	func FunctionNode clone() {
		return FunctionNode_new(this.type, this.position, this.ret_type, this.name, this.args, this.vrbls, this.block, this.scope, this.pure)
	}
}


define t "ListNode"
include "src/stdlib/Option.generic"

func ListNode ListNode_new(NodeType type, Position pos)() {
	return ListNode_new(type, pos, LinkedList<Node>_new())
}

class virtual ListNode < Node (LinkedList<Node> children) {
	func Option<ListNode> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v) {
		for (n in this.children) {
			n_iter.set(n.accept(v).unwrap_or(n))
		}
	}

	func ListNode append(Node n) {
		this.children.append(n)
		return this
	}

	func ListNode prepend(Node n) {
		this.children.prepend(n)
		return this
	}

	func ListNode clone() {
		return ListNode_new(this.type, this.position, this.children)
	}
}



func IfNode IfNode_new(Position pos, Node condition, ListNode block_if) {
	return IfNode_new(nIF, pos, condition, block_if, None<ListNode>)
}

class virtual IfNode < Node (Node condition, ListNode block_if, Option<ListNode> block_else) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.condition = this.condition.accept(v).unwrap_or(this.condition)
		this.block_if = this.block_if.accept(v).unwrap_or(this.block_if)
		if (this.block_else.is_some() == true) {
			var ListNode els = this.block_else.unwrap()
			var ListNode res = els.accept(v).unwrap_or(els)
			this.block_else = Some(res)
		}
	}

	func IfNode clone() {
		return IfNode_new(this.type, this.position, this.condition, this.block_if, this.block_else)
	}
}



func Node LoopNode_new(Position pos, ListNode block)() {
	return LoopNode_new(nLOOP, pos, block)
}

# TODO: Make this a subclass of ListNode?
class virtual LoopNode < Node (ListNode block) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.block = this.block.accept(v).unwrap_or(this.block)
	}

	func LoopNode clone() {
		return LoopNode_new(this.type, this.position, this.block)
	}
}



func Node ReturnNode_new(Position pos, Node expr)() {
	return ReturnNode_new(nRETURN, pos, expr)
}

class virtual ReturnNode < Node (Node expr) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v)(Node n) {
		this.expr = this.expr.accept(v).unwrap_or(this.expr)
	}

	func ReturnNode clone() {
		return ReturnNode_new(this.type, this.position, this.expr)
	}
}



func Node EnumNode_new(Position pos, String name, ListNode values)() {
	return EnumNode_new(nENUM, pos, name, values)
}

class virtual EnumNode < Node (String name, ListNode values) {
	func Option<Node> accept(Visitor v)() {
		return v.visit(this)
	}

	func void accept_children(Visitor v) {
		this.values = this.values.accept(v).unwrap_or(this.values)
	}

	func EnumNode clone() {
		return EnumNode_new(this.type, this.position, this.name, this.values)
	}
}



func ForNode ForNode_new(Position pos, StringNode item, Node iterable, ListNode block)() {
	return ForNode_new(nFOR, pos, item, iterable, block)
}

class virtual ForNode < Node (StringNode item, Node iterable, ListNode block) {
	func Option<Node> accept(Visitor v) {
		return v.visit(this)
	}

	func void accept_children(Visitor v) {
		var item = this.item.accept(v).unwrap_or(this.item).to(StringNode)
		this.item = item
		this.iterable = this.iterable.accept(v).unwrap_or(this.iterable)
		this.block = this.block.accept(v).unwrap_or(this.block)
	}

	func ForNode clone() {
		return ForNode_new(this.type, this.position, this.item, this.iterable, this.block)
	}
}
