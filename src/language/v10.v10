include "src/stdlib/stdlib.v10"
include "src/language/parser/Parser.v10"
include "src/language/Scope.v10"
include "src/language/Type.v10"
include "src/language/Position.v10"

include "src/language/visitors/Visitor.v10"
include "src/language/visitors/Printer.v10"
include "src/language/visitors/Constructor.v10"
include "src/language/visitors/Typing.v10"
include "src/language/visitors/Method.v10"
include "src/language/visitors/Definition.v10"
include "src/language/visitors/Resolving.v10"
include "src/language/visitors/IndexCall.v10"
include "src/language/visitors/Functions.v10"
include "src/language/visitors/Strings.v10"
include "src/language/visitors/Dump.v10"
include "src/language/visitors/Variables.v10"
include "src/language/visitors/Inherit.v10"
include "src/language/visitors/ForLoop.v10"
include "src/language/visitors/TypeCheck.v10"
include "src/language/visitors/Casting.v10"
include "src/language/visitors/PlusMinus.v10"
include "src/language/visitors/ListFunctions.v10"

define t "SourceFile"
include "src/stdlib/Array.generic"

define t "Boolean"
include "src/stdlib/Array.generic"

define k "String"
define v "SourceFile"
include "src/stdlib/Map.generic"

define k "String"
define v "Boolean"
include "src/stdlib/Map.generic"

define t "SourceFile"
include "src/stdlib/LinkedList.generic"

func SourceFile SourceFile_new(String name, Boolean clone, Node ast) {
	return SourceFile_new(name, clone, ast, LinkedList<SourceFile>_new())
}

class SourceFile(String name, Boolean clone, Node ast, LinkedList<SourceFile> reqs) {
	func void print(Number depth) {
		for (x in Range_new(depth)) "  ".print()
		
		this.name.print()
		if (this.clone == true) "*".print()
		":".println()
		
		if (depth > 6) return 0

		depth++
		for (req in this.reqs) {
			req.print(depth)
		}
	}

	# Remove cycles in the sourcefile graph
	# by introducing clones
	func void decycle() this.decycle(Map<String_Boolean>_new(128))
	func void decycle(Map<String_Boolean> encountered) {
		# Mark this source file as encountered
		encountered.set(this.name, true)

		for (req in this.reqs) {
			# Check if required file has already
			# been encountered and replace with a clone
			if (encountered.get(req.name) == true) {
				req_iter.set(SourceFile_new(req.name, true, req.ast))
			} else {
				req.decycle(encountered.shallow_clone())
			}
		}
	}
}

class Main(Map<String_SourceFile> source_files, ListNode tb_functions) {
	# Normalises file names
	# e.g. "LinkedList.v10" => "LinkedList"
	#      "LinkedList"     => "LinkedList"
	func String norm_name(String name) {
		var Number dot_pos = name.length - 4
		if (name.get(dot_pos) == '.') {
			name.length -= 4
		}
		return name
	}

	# Returns SourceFile for given path
	# Uses cached value if available
	func SourceFile get_source_file(String path) {
		var name = this.norm_name(path)

		# Return pre-existing SourceFiles from cache
		var existing = this.source_files.get(name)
		if (existing > 0) {
			return existing
		}

		return this.parse(name)
	}

	# Builds a graph of connected source files
	# Returns a SourceFile with all required children
	func SourceFile parse(String name) {
		"Parsing ".print()
		name.println()

		# Open source file
		var source_path = name.clone(4).append(".v10")
		var input = File_open(source_path)
		if (input < 0) exit(1)

		# Parse file
		var parser = Parser_new(source_path, input)
		var Node ast = parser.parse()

		# Add file to source file cache
		var sf = SourceFile_new(name, false, ast)
		this.source_files.set(name, sf)

		# Retrieve required files
		for (req in parser.reqs) {
			sf.reqs.append(this.get_source_file(req))
		}

		return sf
	}

	func void definition(SourceFile sf, Boolean root_file, Boolean build_deps) {
		"Extracting definitions from ".print()
		sf.name.println()

		sf.ast.accept(Typing_new(sf.scope))
		sf.ast.accept(Inherit_new(sf.scope))
		sf.ast.accept(Constructor_new())
		sf.ast.accept(Method_new(sf.scope))

		# Full build-only defining visitors
		if (root_file == true || build_deps == true) {
			sf.ast.accept(ForLoop_new())
			sf.ast.accept(Variables_new())
		}

		sf.ast.accept(Definition_new(sf.scope))
		#sf.ast.accept(Functions_new(this.tb_funcs, root_file))
	}
}











func LinkedList<String> build(SourceFile pt, Boolean build_deps, Boolean keep_asm, Boolean root_file) {
	#var Number nc = pt
	#nc.to(Number).toString().println()
	"Building file ".print()
	pt.name.println()
	
	var root = pt.ast

	# Construct asm path
	var asm_out = pt.name.clone(4).append(".asm")

	# Create list of external functions
	var ext_funcs = LinkedList<String>_new()

	for (req in pt.reqs) {
		var funs = build(req, build_deps, keep_asm, false)
		for (fun in funs) {
			ext_funcs.append(fun)
		}
	}

	# Resolve and build
	if (root_file == true || build_deps == true) {
		############################
		#    RESOLVING VISITORS    #
		############################

		root.accept(PlusMinus_new())
		root.accept(Casting_new())
		root.accept(Resolving_new())
		#root.accept(TypeCheck_new())
		root.accept(IndexCall_new())
		root.accept(Strings_new())

		# Dump asm to file
		var output = File_create(asm_out)
		if (output < 0) exit(1)
		root.accept(Dump_new(output, root_file, ext_funcs))


		##################
		#    ASSEMBLY    #
		##################

		"Assembling file ".print()
		pt.name.println()

		# Assemble
		# nasm -f elf64 out.asm
		Run_new(4).add("/usr/bin/nasm").add("-f").add("elf64").add(asm_out).exec()

		# Clean up generated asm file
		if (keep_asm == false) File_delete(asm_out)
	}

	# Get a list of all exported functions
	ext_funcs.length.toString().println()
	root.accept(ListFunctions_new(ext_funcs))
	ext_funcs.length.toString().println()

	return ext_funcs
}

func void main(CharArr comp, CharArr source_path, CharArr out_path, CharArr caflags)(Stream input, Stream output, Parser parser, Node root, Visitor v, Scope sc) {
	# Read flags
	var build_deps = true  # Build required dependencies
	var link       = true  # Link created object files into executable
	var keep_asm   = false # Keep generated asm files
	var keep_obj   = true  # Keep generated object files
	var obj_force  = false # Force build of up to date object files

	if (caflags != 0) {
		var flags = String_fromTerminated(caflags)
		if (flags.contains('h') == true) {
			"Straps Compiler".println()
			"Usage: straps SOURCE_FILE OUTPUT_EXECUTABLE [-flags]\n".println()
			"Flags:".println()
			"  h - Display this help text".println()
			"  d - Don't build required dependencies".println()
			"  l - Don't link object files into a final executable".println()
			"  a - Keep generated asm files".println()
			"  o - Delete generated object files".println()
			"  f - Force the build of up to date object files".println()
			exit()
		}
		if (flags.contains('d') == true) build_deps = false
		if (flags.contains('l') == true) link       = false
		if (flags.contains('a') == true) keep_asm   = true
		if (flags.contains('o') == true) keep_obj   = false
		if (flags.contains('f') == true) obj_force  = true
	}

	sc = Scope_new()
	scope = sc

	var pos = Position_new(MetaCharacter_new('?', 0, 0), "GLOBALS_SETUP")
	sc.set("rax", StringNode_new(nREGISTER, pos, Type_new(), "rax").toNode())
	sc.set("rbx", StringNode_new(nREGISTER, pos, Type_new(), "rbx").toNode())
	sc.set("rcx", StringNode_new(nREGISTER, pos, Type_new(), "rcx").toNode())
	sc.set("rdx", StringNode_new(nREGISTER, pos, Type_new(), "rdx").toNode())
	sc.set("rsp", StringNode_new(nREGISTER, pos, Type_new(), "rsp").toNode())
	sc.set("rbp", StringNode_new(nREGISTER, pos, Type_new(), "rbp").toNode())
	sc.set("rsi", StringNode_new(nREGISTER, pos, Type_new(), "rsi").toNode())
	sc.set("rdi", StringNode_new(nREGISTER, pos, Type_new(), "rdi").toNode())
	sc.set("r12", StringNode_new(nREGISTER, pos, Type_new(), "r12").toNode())
	sc.set("r13", StringNode_new(nREGISTER, pos, Type_new(), "r13").toNode())

	load_loop()

	var source_files = Map<String_SourceFile>_new(128)
	var lfuncs = ListNode_new(nFUNCTIONS, Position_new(MetaCharacter_new('?', 0, 0), "Functions"))

	var mobj = Main_new(source_files, lfuncs)
	var sf = mobj.get_source_file(String_fromTerminated(source_path))
	sf.print(0)
	sf.decycle()
	sf.print(0)

	#var PT = parse(String_fromTerminated(source_path), build_deps, keep_asm, true, source_files, lfuncs)
	#build(PT, build_deps, keep_asm, true)
	link = false

	# Link object files into executable
	if (link == true) {
		# Get number of arguments
		var Number arg_cnt = source_files.keys.length + 5

		# ld -m elf_x86_64 -o out_path out.o
		var ld = Run_new(arg_cnt).add("/usr/bin/ld").add("-m").add("elf_x86_64")
														 .add("-o").add(String_fromTerminated(out_path))

		# Add object paths to arguments
		for (obj in source_files.keys) {
			ld.add(obj)
		}

		# Run command
		ld.exec()
	}

	# Clean up object files
	if (keep_obj == false) {
		for (obj in source_files.keys) {
			File_delete(obj)
		}
	}
}
