include "src/stdlib/stdlib.v10"
include "src/language/parser/Parser.v10"
include "src/language/Scope.v10"
include "src/language/Type.v10"
include "src/language/Position.v10"
include "src/language/Reporting.v10"

include "src/language/visitors/Visitor.v10"
include "src/language/visitors/Printer.v10"
include "src/language/visitors/Constructor.v10"
include "src/language/visitors/Typing.v10"
include "src/language/visitors/Method.v10"
include "src/language/visitors/Definition.v10"
include "src/language/visitors/Resolving.v10"
include "src/language/visitors/IndexCall.v10"
include "src/language/visitors/Functions.v10"
include "src/language/visitors/Strings.v10"
include "src/language/visitors/Dump.v10"
include "src/language/visitors/Variables.v10"
include "src/language/visitors/Inherit.v10"
include "src/language/visitors/ForLoop.v10"
include "src/language/visitors/TypeCheck.v10"
include "src/language/visitors/Casting.v10"
include "src/language/visitors/PlusMinus.v10"
include "src/language/visitors/Statics.v10"
include "src/language/visitors/StaticNew.v10"
include "src/language/visitors/Externals.v10"

define k "String"
define v "Headers"
include "src/stdlib/Map.generic"

define t "Headers"
include "src/stdlib/Array.generic"

define t "Headers"
include "src/stdlib/LinkedList.generic"

define t "Headers"
include "src/stdlib/Set.generic"

global(Scope scope)

# Normalises file names
# e.g. "LinkedList.v10" => "LinkedList"
#      "LinkedList"     => "LinkedList"
func String norm_name(String name) {
	var Number dot_pos = name.length - 4
	if (name.get(dot_pos) == '.') {
		name.length -= 4
	}
	return name
}

class Headers (
	String name,
	Set<Headers> reqs,
	ListNode trace_functions,
	LinkedList<String> externals,
	Scope scope
) {
		func Boolean equal(Headers other) {
		return this.name.equal(other.name)
	}

	func void print() this.print(2)

	func void print(Number depth) {
		if (depth < 0) return 0
		depth--
		"{name:".print()
		this.name.print()
		",reqs:[".print()
		for (hdr in this.reqs) hdr.print(depth)
		"]},".print()
	}

	func Headers fix(Set<Headers> already_fixed) {
		if (already_fixed.contains(this) == true) return this
		already_fixed.add(this)
		"Fixing ".print()
		this.name.println()
		for(req in this.reqs) {
			req.fix(already_fixed)
			for(rr in req.reqs) {
				this.reqs.add(rr)
			}
		}
		return this
	}
}

class Builder(Set<String> built_files, Map<String_Headers> header_cache) {
	# Returns all headers (including headers of required files) for a single file
	func Headers get_headers(String name) {
		# Return cached headers if this file has already been processed
		var headers = this.header_cache.get(name)
		if (headers > 0) {
			name.print()
			":cached".println()
			return headers
		}

		# Add this requirement to the glob_reqs
		this.built_files.add(name)

		# Parse the source file
		var src_path = name.clone(4).append(".v10")
		var parser = Parser_new(src_path, File_open(src_path))
		var root = parser.parse()
		name.print()
		":get_headers".println()

		# Create scope, externals and trace_functions for this file
		var trace_funcs = ListNode_new(nFUNCTIONS, Position_new(MetaCharacter_new('?', 0, 0), "get_all_headers"))
		var externals = LinkedList<String>_new()
		var reqs = Set<Headers>_new()
		scope = Scope_new()

		headers = Headers_new(name, reqs, trace_functions, externals, scope)
		this.header_cache.set(name, headers)

		for (req in parser.reqs) {
			# Skip file if it has already been built
			if (this.built_files.contains(name) == true) {
				name.print()
				":skip_req".println()
				next
			}

			var req_head = this.get_headers(req)
			reqs.add(req_head)

			# Add items from requirement's scope
			for (pair in req_head.scope.scope) sc.set(pair.key, pair.value, 1337)
		}

		"Got past all req headers for ".print()
		name.println()
		scope.print()
		"\n".print()

		# Run visitors over the file's AST
		root.accept(Externals_new(externals))
		root.accept(Typing_new())
		root.accept(Inherit_new())
		root.accept(StaticNew_new())
		root.accept(Constructor_new())
		root.accept(Method_new())
		root.accept(Definition_new())
		root.accept(Functions_new(trace_functions))

		"Done ".print()
		name.println()
		headers.scope.print()
		"\n".print()

		return headers
	}
}


func void main(CharArr comp, CharArr src_path, CharArr out_path, CharArr caflags) {
	load_loop()

	# Read flags
	var keep = false
	var report = false
	if (caflags != 0) {
		var flags = String_fromTerminated(caflags)
		if (flags.length > 1 && flags.get(1) == 'k') keep = true
		if (flags.length > 2 && flags.get(2) == 'r') report = true
	}

	var reporting = Reporting_new(report, STDOUT)
	var header_cache = Map<String_Headers>_new(512)

	var name = norm_name(String_fromTerminated(src_path))
	var glob_reqs = build(name, reporting, header_cache)

	if (report == true) return 0

	# Set up linker runner
	var Number num_args = glob_reqs.length + 5
	var linker = Run_new(num_args)
	linker.add("/usr/bin/ld").add("-m").add("elf_x86_64").add("-o").add(String_fromTerminated(out_path))

	for (req in glob_reqs) {
		if (req == glob_reqs.first.payload) next
		build(req, reporting, header_cache)

		# Add object to linker args
		linker.add(req.clone(2).append(".o"))
	}

	# ld -m elf_x86_64 -o out_path out.o
	linker.add(name.clone(2).append(".o")).exec()

	# # Clean up
	# if (keep == false) {
	# 	File_delete("out.asm")
	# 	# File_delete("out.o")
	# }

	return 0
}

func Set<String> build(String name, Reporting reporting, Map<String_Headers> header_cache) {
	# Open input file
	var src_path = name.clone(4).append(".v10")
	var input = File_open(src_path)
	if (input < 0) { return 0 }

	var sc = Scope_new()
	scope = sc
	var parser = Parser_new(src_path, input)
	var root = parser.parse()
	name.print()
	":build".println()

	# Open output file
	var asm_path = name.clone(4).append(".asm")
	var output = File_create(asm_path)
	if (output < 0) { return 0 }

	var pos = Position_new(MetaCharacter_new('?', 0, 0), "MainFunctions")
	var glob_reqs = Set<String>_new()
	glob_reqs.add(name)

	var req_headers = Builder_new(glob_reqs, header_cache).get_all_headers(parser.reqs)
	scope = req_headers.scope

	"section .text".println(output)
	for (fnc in req_headers.trace_functions.children) {
		"extern ".print(output)
		fnc.to(StringNode).string.println(output)
		fnc_iter.fetch()
	}
	for (extern in req_headers.externals) {
		"extern ".print(output)
		extern.println(output)
	}

	var pos = Position_new(MetaCharacter_new('?', 0, 0), "GLOBALS_SETUP")
	sc.set("rax", StringNode_new(nREGISTER, pos, Type_new(), "rax").toNode(), 1337)
	sc.set("rbx", StringNode_new(nREGISTER, pos, Type_new(), "rbx").toNode(), 1337)
	sc.set("rcx", StringNode_new(nREGISTER, pos, Type_new(), "rcx").toNode(), 1337)
	sc.set("rdx", StringNode_new(nREGISTER, pos, Type_new(), "rdx").toNode(), 1337)
	sc.set("rsp", StringNode_new(nREGISTER, pos, Type_new(), "rsp").toNode(), 1337)
	sc.set("rbp", StringNode_new(nREGISTER, pos, Type_new(), "rbp").toNode(), 1337)
	sc.set("rsi", StringNode_new(nREGISTER, pos, Type_new(), "rsi").toNode(), 1337)
	sc.set("rdi", StringNode_new(nREGISTER, pos, Type_new(), "rdi").toNode(), 1337)
	sc.set("r12", StringNode_new(nREGISTER, pos, Type_new(), "r12").toNode(), 1337)
	sc.set("r13", StringNode_new(nREGISTER, pos, Type_new(), "r13").toNode(), 1337)

	root.accept(PlusMinus_new())
	root.accept(Statics_new())
	root.accept(Casting_new())
	root.accept(ForLoop_new())
	root.accept(Variables_new())
	root.accept(Typing_new())
	root.accept(Inherit_new())
	root.accept(StaticNew_new())
	root.accept(Constructor_new())
	root.accept(Method_new())
	root.accept(Definition_new())
	root.accept(Resolving_new(reporting))
	root.accept(TypeCheck_new(reporting))

	if (reporting.enabled == true) return 0

	root.accept(IndexCall_new())
	root.accept(Functions_new(req_headers.trace_functions))
	root.accept(Strings_new())
	root.accept(Dump_new(output))

	# nasm -f elf64 out.asm
	var obj_path = name.clone(2).append(".o")
	Run_new(6).add("/usr/bin/nasm").add("-f").add("elf64").add(asm_path).add("-o").add(obj_path).exec()

	return glob_reqs
}
