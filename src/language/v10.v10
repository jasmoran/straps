include "src/stdlib/stdlib.v10"
include "src/language/parser/Parser.v10"
include "src/language/Scope.v10"
include "src/language/Type.v10"
include "src/language/Position.v10"

include "src/language/visitors/Visitor.v10"
include "src/language/visitors/Printer.v10"
include "src/language/visitors/Constructor.v10"
include "src/language/visitors/Typing.v10"
include "src/language/visitors/Method.v10"
include "src/language/visitors/Definition.v10"
include "src/language/visitors/Resolving.v10"
include "src/language/visitors/IndexCall.v10"
include "src/language/visitors/Functions.v10"
include "src/language/visitors/Strings.v10"
include "src/language/visitors/Dump.v10"
include "src/language/visitors/Variables.v10"
include "src/language/visitors/Inherit.v10"
include "src/language/visitors/ForLoop.v10"
include "src/language/visitors/TypeCheck.v10"
include "src/language/visitors/Casting.v10"
include "src/language/visitors/PlusMinus.v10"
include "src/language/visitors/ListFunctions.v10"

define t "LinkedList<String>"
include "src/stdlib/Array.generic"

define k "String"
define v "LinkedList<String>"
include "src/stdlib/Map.generic"

global(Scope scope)

# Returns: List of all functions defined in
#          built file and its dependencies
func LinkedList<String> build(String name, Boolean build_deps, Boolean keep_asm, Boolean root_file, Map<String_LinkedList<String>> source_files, ListNode lfuncs) {
	#######################
	#    FILE HANDLING    #
	#######################
	
	# Normalise source file path
	var String source_path = 0
	var Number dot_pos = name.length - 4
	if (name.get(dot_pos) == '.') {
		source_path = name.clone()
		name.length -= 4
	} else {
		source_path = name.clone(4).append(".v10")
	}

	# Construct obj and asm paths
	var asm_out = name.clone(4).append(".asm")
	var obj_out = name.clone(2).append(".o")

	# Dont rebuild files
	var existing = source_files.get(obj_out)
	if (existing > 0) return existing

	# Open source file
	var input = File_open(source_path)
	if (input < 0) exit(1)
	

	#################
	#    PARSING    #
	#################

	"Parsing file ".print()
	source_path.println()

	# Parse file
	var parser = Parser_new(source_path, input)
	var Node root = parser.parse()

	# Create list of external functions
	var ext_funcs = LinkedList<String>_new()

	# Parse required files
	for (req in parser.reqs) {
		var funs = build(req, build_deps, keep_asm, false, source_files, lfuncs)
		for (fun in funs) {
			ext_funcs.append(fun)
		}
	}

	# Add file to source file map
	source_files.set(obj_out, ext_funcs)


	###########################
	#    DEFINING VISITORS    #
	###########################

	root.accept(Typing_new())
	root.accept(Inherit_new())
	root.accept(Constructor_new())
	root.accept(Method_new())

	# Full build-only defining visitors
	if (root_file == true || build_deps == true) {
		root.accept(ForLoop_new())
		root.accept(Variables_new())
	}

	root.accept(Definition_new())
	root.accept(Functions_new(lfuncs, root_file))

	# Resolve and build
	if (root_file == true || build_deps == true) {
		############################
		#    RESOLVING VISITORS    #
		############################

		root.accept(PlusMinus_new())
		root.accept(Casting_new())
		root.accept(Resolving_new())
		root.accept(TypeCheck_new())
		root.accept(IndexCall_new())
		root.accept(Strings_new())

		# Dump asm to file
		var output = File_create(asm_out)
		if (output < 0) exit(1)
		root.accept(Dump_new(output, root_file, ext_funcs))


		##################
		#    ASSEMBLY    #
		##################

		"Assembling file ".print()
		source_path.println()

		# Assemble
		# nasm -f elf64 out.asm
		Run_new(4).add("/usr/bin/nasm").add("-f").add("elf64").add(asm_out).exec()

		# Clean up generated asm file
		if (keep_asm == false) File_delete(asm_out)
	}

	# Get a list of all exported functions
	root.accept(ListFunctions_new(ext_funcs))

	return ext_funcs
}

func void main(CharArr comp, CharArr source_path, CharArr out_path, CharArr caflags)(Stream input, Stream output, Parser parser, Node root, Visitor v, Scope sc) {
	# Read flags
	var build_deps = true  # Build required dependencies
	var link       = true  # Link created object files into executable
	var keep_asm   = false # Keep generated asm files
	var keep_obj   = true  # Keep generated object files
	var obj_force  = false # Force build of up to date object files

	if (caflags != 0) {
		var flags = String_fromTerminated(caflags)
		if (flags.contains('h') == true) {
			"Straps Compiler".println()
			"Usage: straps SOURCE_FILE OUTPUT_EXECUTABLE [-flags]\n".println()
			"Flags:".println()
			"  h - Display this help text".println()
			"  d - Don't build required dependencies".println()
			"  l - Don't link object files into a final executable".println()
			"  a - Keep generated asm files".println()
			"  o - Delete generated object files".println()
			"  f - Force the build of up to date object files".println()
			exit()
		}
		if (flags.contains('d') == true) build_deps = false
		if (flags.contains('l') == true) link       = false
		if (flags.contains('a') == true) keep_asm   = true
		if (flags.contains('o') == true) keep_obj   = false
		if (flags.contains('f') == true) obj_force  = true
	}

	sc = Scope_new()
	scope = sc

	var pos = Position_new(MetaCharacter_new('?', 0, 0), "GLOBALS_SETUP")
	sc.set("rax", StringNode_new(nREGISTER, pos, Type_new(), "rax").toNode())
	sc.set("rbx", StringNode_new(nREGISTER, pos, Type_new(), "rbx").toNode())
	sc.set("rcx", StringNode_new(nREGISTER, pos, Type_new(), "rcx").toNode())
	sc.set("rdx", StringNode_new(nREGISTER, pos, Type_new(), "rdx").toNode())
	sc.set("rsp", StringNode_new(nREGISTER, pos, Type_new(), "rsp").toNode())
	sc.set("rbp", StringNode_new(nREGISTER, pos, Type_new(), "rbp").toNode())
	sc.set("rsi", StringNode_new(nREGISTER, pos, Type_new(), "rsi").toNode())
	sc.set("rdi", StringNode_new(nREGISTER, pos, Type_new(), "rdi").toNode())
	sc.set("r12", StringNode_new(nREGISTER, pos, Type_new(), "r12").toNode())
	sc.set("r13", StringNode_new(nREGISTER, pos, Type_new(), "r13").toNode())

	load_loop()

	var source_files = Map<String_LinkedList<String>>_new(128)
	var lfuncs = ListNode_new(nFUNCTIONS, Position_new(MetaCharacter_new('?', 0, 0), "Functions"))

	build(String_fromTerminated(source_path), build_deps, keep_asm, true, source_files, lfuncs)

	# Link object files into executable
	if (link == true) {
		# Get number of arguments
		var Number arg_cnt = source_files.keys.length + 5

		# ld -m elf_x86_64 -o out_path out.o
		var ld = Run_new(arg_cnt).add("/usr/bin/ld").add("-m").add("elf_x86_64")
														 .add("-o").add(String_fromTerminated(out_path))

		# Add object paths to arguments
		for (obj in source_files.keys) {
			ld.add(obj)
		}

		# Run command
		ld.exec()
	}

	# Clean up object files
	if (keep_obj == false) {
		for (obj in source_files.keys) {
			File_delete(obj)
		}
	}
}
