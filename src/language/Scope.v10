func Scope Scope_new()(Scope sc) {
	sc = 0
	return Scope_new("GLOBAL", sc)
}

func Scope Scope_new(String name, Scope parent)(Map<String_Node> sc) {
	sc = Map<String_Node>_new(2048)
	return Scope_new(name, parent, sc)
}

class Scope (String name, Scope parent, Map<String_Node> scope) {
	func Node get(String name)() {
		return this.scope.get(name)
	}

	func void set(String name, Node node) {
		this.scope.set(name, node)
	}

	func void set(String name, String uglyname, FunctionNode node) {
		var ListNode capsule = this.scope.get(uglyname)
		if (capsule < 1) capsule = ListNode_new(nBLOCK)
		capsule.prepend(node.toNode())
		this.scope.set(uglyname, capsule.toNode())

		capsule = this.scope.get(name)
		if (capsule < 1) {
			"^".print()
			node.args.children.length.toString().print()
			name.println()
			capsule = ListNode_new(nBLOCK)
		}
		capsule.append(node.toNode())
		if(name.equal("error") == true) {
			for (item in capsule.children) {
				var Number num = item
				num.toString().println()
			}
		}
		this.scope.set(name, capsule.toNode())
	}

	func Number match(StringNode arg, StringNode optarg) {
		var Scope sc = scope
		optarg.ret_type.resolve(sc)
		if (optarg.ret_type.res == 0) error("Option arg unresolved in match")
		optarg.ret_type.raw.print()
		": ".print()

		var argtype = arg.ret_type
		var rank = 0
		loop {
			if (argtype == 0) return 0
			argtype.resolve(sc)
			if (argtype.res == 0) return 0

			argtype.raw.print()
			", ".print()

			rank++
			if (argtype.res == optarg.ret_type.res) return rank

			argtype = argtype.res.parent
		}
		return 0
	}

	func FunctionNode resolve(String name, String uglyname, LinkedList<StringNode> args) {
		uglyname.println()
		var ListNode lnoptions = this.resolve(name)
    var LinkedList<FunctionNode> options = lnoptions.children
		"Opt len: ".print()
		options.length.toString().println()
    # Track the best option, best is the distance => smaller is better
    var FunctionNode best_match = 0
    var best = 9999

    # Loop through each possible match
    for (option in options) {
      var LinkedList<StringNode> optargs = option.args.children
			"Option =>".print()
			optargs.length.toString().print()
			for (opt in optargs) opt.ret_type.raw.print()
			"\n".print()
      if (optargs.length != args.length) next
			if (args.length == 0) {
        best = rank
        best_match = option
      }

      var rank = 0

      # Loop through each of the options args
      for (index in Range_new(args.length)) {
        # Returns the distance from the arg type to the optarg type
        var match = this.match(args.get(index), optargs.get(index))
				match.toString().println()
        if (match > 0) {
          rank += match
        } else {
          # No match
          rank = 0
          break
        }
      }

      # Check how this option compares
      if (rank > 0 && rank < best) {
        best = rank
        best_match = option
      }
    }

		if (best_match == 0) {
			"Act Args: ".print()
			for (opt in args) opt.ret_type.raw.println()
			name.print()
			" args.length = ".print()
			args.length.toString().print()
			" options.length = ".print()
			options.length.toString().println()
			#exit()
		} else {
			"XXX".println()
		}

		lnoptions = this.resolve(uglyname)
		var normal_match = lnoptions.children.get(0)
		if (best_match != normal_match) {
			error("Normal and best matches don't match")
		}

    # Check we found a match
    if (best_match == 0) error("Could not resolve function ", name, " args don't match")

		# Ignore everything above for now
		return normal_match
	}

	func Node resolve(String name)(Scope s, Node res) {
		s = this
		if (s == 0) error("Attempted to resolve on NULL scope")
		loop {
			if (s == 0) break
			res = s.get(name)
			if (res > 0) return res
			s = s.parent
		}

		# Add special GLOBAL scope check
		s = scope
		res = s.get(name)
		if (res > 0) return res
		error("Could not resolve value ", name)
	}

	func void print()(Number index, Visitor printer) {
		index = 0
		printer = Printer_new(1, STDOUT, 1)
		loop {
			if (this.scope.keys.length == index) break
			this.scope.keys.get(index).print()
			": <<".println()
			this.scope.values.get(index).accept(printer)
			">>".println()
			index++
		}
	}
}
