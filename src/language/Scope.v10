func Scope Scope_new()(Scope sc) {
	sc = 0
	return Scope_new("GLOBAL", sc)
}

func Scope Scope_new(String name, Scope parent)(Map<String_Node> sc) {
	sc = Map<String_Node>_new(2048)
	return Scope_new(name, parent, sc)
}

class Scope (String name, Scope parent, Map<String_Node> scope) {
	func Node get(String name)() {
		return this.scope.get(name)
	}

	func void set(String name, Node node) {
		this.scope.set(name, node)
	}

	func void set(String name, FunctionNode node) {
		var ListNode capsule = this.scope.get(name)
		if (capsule < 1) capsule = ListNode_new(nBLOCK, Position_new(MetaCharacter_new('?', 0, 0), "Scope Capsule"))
		capsule.append(node.toNode())

		this.scope.set(name, capsule.toNode())
	}

	func Option<FunctionNode> resolve(StringNode name, LinkedList<RetNode> args) {
		var ListNode lnoptions = this.search(name.string)

		if (lnoptions > 0 && lnoptions.type == nBLOCK) {
			var LinkedList<FunctionNode> options = lnoptions.children

			# Track the best option, best is the distance => smaller is better
			var FunctionNode best_match = 0
			var best = 9999

			# Loop through each possible match
			for (option in options) {
				var LinkedList<RetNode> optargs = option.args.children
				if (optargs.length != args.length) next

				# Nothing to compare if there are no arguments
				if (args.length == 0) {
					best_match = option
					break
				}

				var rank = 0

				# Loop through each of the options args
				for (index in Range_new(args.length)) {
					var opt_type = optargs.get(index).ret_type
					var arg_type = args.get(index).ret_type
					opt_type.resolve(scope)
					# Returns the distance from the arg type to the optarg type
					var match = opt_type.child_rank(arg_type)

					if (match > 0) {
						rank += match
					} else {
						# No match
						rank = 0
						break
					}
				}

				# Check how this option compares
				if (rank > 0 && rank < best) {
					best = rank
					best_match = option
				}
			}

			# Check we found a match
			if (best_match != 0) return Some(best_match.clone())
		}

		return None<FunctionNode>
	}

	func Option<Node> resolve(StringNode name) {
		var ListNode res = this.search(name.string)

		# Can't clone here because Inferring process needs to modify the
		# existing identifier in the scope not a clone.
		if (res > 0 && res.type != nBLOCK) return Some(res)

		# Just use unresolved identifier
		return None<Node>
	}

	func Node search(String name) {
		var s = this
		if (s == 0) error("Attempted to resolve on NULL scope")
		loop {
			if (s == 0) break
			var res = s.get(name)
			if (res > 0) return res
			s = s.parent
		}

		return res
	}

	func void print()(Number index, Visitor printer) {
		index = 0
		printer = Printer_new(1, STDOUT, 1)
		loop {
			if (this.scope.keys.length == index) break
			this.scope.keys.get(index).print()
			": <<".println()
			this.scope.values.get(index).accept(printer)
			">>".println()
			index++
		}
	}
}
