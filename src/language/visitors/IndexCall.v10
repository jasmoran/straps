func IndexCall IndexCall_new()(LinkedList<Node> pl, LinkedListNode<Node> plln) {
	pl = 0
	plln = 0
	var Visitor v = 0
	var pos = Position_new(MetaCharacter_new('?', 0, 0), "IndexCall_scratchreg")
	var ixc = IndexCall_new(v, pl, plln, StringNode_new(nREGISTER, pos, Type_new(), "r12").toNode(), pos)
	ixc.v = ixc
	return ixc
}

class virtual IndexCall < Visitor (Visitor v, LinkedList<Node> parent_list,
                                   LinkedListNode<Node> parent_lln, Node scratch_reg, Position pos) {

	func void prepend(Node child) {
		if (this.parent_list == 0) error("Attempted to prepend when not enclosed by a block")
		this.parent_list.insert_before(this.parent_lln, child)
	}

	func void visit(CallNode n) {
		# Loop through arguments from last to first
		for (arg in n.args.iter().reverse()) {
			# Visit argument
			var nn = arg.accept(this.v)
			if (nn != 0) {
				arg = nn
				arg_iter.set(arg)
			}

			# Push each argument onto block
			this.prepend(
				UnaryOperationNode_new(PUSH, arg.toNode(), true).toNode()
			)
		}

		# Visit function
		var nn = n.cfunction
		nn = nn.accept(this.v)
		if (nn != 0) n.cfunction = nn

		# Actually call function after pushing arguments
		this.prepend(n.toNode())

		# Replace with rax
		return StringNode_new(nREGISTER, this.pos, Type_new(), "rax")
	}

	func void visit(BinaryOperationNode n)(Node nn, Boolean dumb_or, BinaryOperationNode child, ListNode args) {
		# Visit left hand side
		nn = n.lhs
		nn = nn.accept(this.v)
		if (nn != 0) n.lhs = nn

		dumb_or = false
		if (n.op == DOT) dumb_or = true
		if (n.op == SQUARE_OPEN) dumb_or = true

		if (dumb_or == true) {
			# Check if lhs is also DOT/SQUARE_OPEN
			if (n.lhs.type == nBINARYOP) {
				child = n.lhs

				dumb_or = false
				if (child.op == DOT) dumb_or = true
				if (child.op == SQUARE_OPEN) dumb_or = true
				if (dumb_or == true) {
					# Move lhs to parent block
					this.prepend(
						BinaryOperationNode_new(
							n.position.clone("IndexCall"),
							ASSIGN,
							this.scratch_reg,
							n.lhs
						).toNode()
					)
					n.lhs = this.scratch_reg
				}
			}
		} else {
			# Visit right hand side
			this.scratch_reg = StringNode_new(nREGISTER, this.pos, Type_new(), "r13")
			nn = n.rhs
			nn = nn.accept(this.v)
			if (nn != 0) n.rhs = nn

			child = n.rhs

			dumb_or = false
			if (child.op == DOT) dumb_or = true
			if (child.op == SQUARE_OPEN) dumb_or = true
			if (dumb_or == true) {
				# Move rhs to parent block
				this.prepend(
					BinaryOperationNode_new(
						n.position.clone("IndexCall"),
						ASSIGN,
						this.scratch_reg,
						n.rhs
					).toNode()
				)
				n.rhs = this.scratch_reg
			}
			this.scratch_reg = StringNode_new(nREGISTER, this.pos, Type_new(), "r12")
		}

		return 0
	}

	func void visit(ListNode n) {
		if (n.type == nBLOCK) {
			var prev_list = this.parent_list
			this.parent_list = n.children

			var lln = n.children.first
			loop {
				if (lln == 0) { break }
				n = lln.payload

				var prev_lln = this.parent_lln
				this.parent_lln = lln

				n = n.accept(this.v)

				this.parent_lln = prev_lln

				if (n != 0) {
					# Guard against function return rax being placed directly in a block
					if (n.type == nREGISTER) n = ListNode_new(nBLOCK)

					lln.payload = n
				}
				lln = lln.fwrd
			}

			this.parent_list = prev_list
		} else {
			n.accept_children(this.v)
		}

		return 0
	}
}
