func Resolving Resolving_new()(?T, Scope sc) {
	define V "Resolving"
	include "src/language/visitors/init.v10"
	sc = scope
	v = Resolving_new(?U, sc, true)
	v.v = v
	return v
}

class Resolving(?T, Scope scope, Boolean resolve_idents) {
	func void visit(StringNode n)(Node replacement) {
		n.ret_type.resolve(this.scope)
		if (n.type == nIDENTIFIER) {
			if (this.resolve_idents == true) n = this.scope.resolve(n.string)
		}
		return n
	}

	func void visit(FunctionNode n)(Scope prev_scope, ListNode block) {
		prev_scope = this.scope
		this.scope = n.scope
		n.ret_type.resolve(this.scope)

		# Dont resolve identifiers in vars and args
		this.resolve_idents = false
		n.args.visit(this.v)
		n.vars.visit(this.v)
		this.resolve_idents = true
		n.block.visit(this.v)

		this.scope = prev_scope
		return n
	}

	func void visit(BinaryOperationNode n)(Scope prev_scope, StringNode sn,
																				 BinaryOperationNode dot, ListNode args,
																				 LinkedListNode lln, StringNode field,
																				 Node nn, String method) {
		# Handle fields
		if (n.op == DOT) {
			# Resolve first item
			sn = n.lhs
			n.lhs = sn.m_visit(this)

			# Save current scope
			prev_scope = this.scope

			# Set scope to that of the first items type
			sn = n.lhs
			sn.ret_type.resolve(this.scope)
			this.scope = sn.ret_type.getScope()
			if (this.scope == 0) this.scope = prev_scope

			# Resolve second item
			sn = n.rhs
			n.rhs = sn.m_visit(this)

			# Inherit ret_type from rhs
			sn = n.rhs
			n.ret_type = sn.ret_type

			# Restore scope
			this.scope = prev_scope

			return n
		}

		if (n.op == PAREN_OPEN) {
			# Resolve args
			args = n.rhs
			n.rhs = args.m_visit(this)

			method = String_new(128)
			dot = n.lhs
			if (n.lhs.type == nBINARYOP) {
				if (dot.op == DOT) {
					# Resolve lhs of dot
					sn = dot.lhs
					sn = sn.m_visit(this)
					method.append('_').append(sn.ret_type.raw).append('_')

					# Add lhs of dot to beginning of arguments
					args.prepend(sn.toNode())

					# rhs of dot becomes new lhs of paren_open
					n.lhs = dot.rhs
				}
			}

			# Lengthen function name
			sn = n.lhs
			sn.string = String_new(256).append(method).append(sn.string)

			# Add args to function name
			lln = args.children.first
			loop {
				if (lln == 0) { break }
				field = lln.payload

				# Append type to function name
				sn.string.append('_').append(field.ret_type.raw)

				lln = lln.fwrd
			}

			# Resolve function
			n.lhs = sn.m_visit(this)

			# Inherit ret_type from function
			sn = n.lhs
			n.ret_type = sn.ret_type

			return n
		}

		n.visit_children(this.v)

		return n
	}

	func void visit(ListNode n)() {
		if (n.type != nGLOBAL) {
			n.visit_children(this.v)
		}

		return n
	}

	func void visit(EnumNode n)() {
		return n
	}


	func void visit(ClassNode n)() {
		n.visit_children(this.v)
		return n
	}

	func void visit(Node n)() {
		return n
	}

	func void visit(UnaryOperationNode n)() {
		n.visit_children(this.v)
		return n
	}

	func void visit(IfNode n)() {
		n.visit_children(this.v)
		return n
	}

	func void visit(LoopNode n)() {
		n.visit_children(this.v)
		return n
	}

	func void visit(ReturnNode n)() {
		n.visit_children(this.v)
		return n
	}

}
