func Resolving Resolving_new()(Scope sc) {
	sc = scope
	var Visitor v = 0
	var res = Resolving_new(v, sc, true)
	res.v = res
	return res
}

class virtual Resolving < Visitor (Visitor v, Scope scope, Boolean resolve_idents) {
	func void visit(StringNode n)(Node replacement) {
		n.ret_type.resolve(this.scope)
		if (n.type == nIDENTIFIER) {
			if (this.resolve_idents == true) n = this.scope.resolve(n.string)
		}
		return n
	}

	func void visit(FunctionNode n)(Scope prev_scope, ListNode block) {
		prev_scope = this.scope
		this.scope = n.scope
		n.ret_type.resolve(this.scope)

		# Dont resolve identifiers in vars and args
		this.resolve_idents = false
		n.args.accept(this.v)
		n.vrbls.accept(this.v)
		this.resolve_idents = true
		n.block.accept(this.v)

		this.scope = prev_scope
		return n
	}

	func void visit(CallNode n) {
		# Target of arg fixing, default to normal function
		var StringNode name = n.cfunction

		# If a method, args fixing target is different
		var BinaryOperationNode binop = n.cfunction
		if (binop.type == nBINARYOP && binop.op == DOT) {
			name = binop.rhs
		}

		# Resolve arguments
		n.accept_args(this.v)

		# Detect "pointer" methods, marked with m_
		var fixargs = true
		if (name.string < 1000) {
			#error("NULL-ish string node as function name")
			fixargs = false
		}

		#if (name.type != nIDENTIFIER && name.type != nFUNCTION) {
		#	error("Function name is not an identifier it is a ", name.type.toString())
		#}

		# Fix arguments into function name
		if (name.type == nIDENTIFIER && fixargs == true) {
			# Extend function name
			name.string = name.string.clone(256)

			# Add args to function name
			for (arg in n.args) {
				# Append type to function name
				var type = arg.ret_type.raw
				if (type < 2) error("Unknown type in call to ", name.string, "...")
				name.string.append('_').append(type)
			}
		}

		# If function is a DOT, add its LHS to arguments (this)
		binop = n.cfunction
		if (binop.type == nBINARYOP && binop.op == DOT) {
		 	if (binop.rhs.type == nIDENTIFIER || binop.rhs.type == nFUNCTION) {
				var StringNode nn = binop.lhs
				nn = nn.accept(this.v)
				n.args.prepend(nn)
			}
		}

		# Resolve function
		nn = n.cfunction
		n.cfunction = nn.accept(this.v)

		# Fix up dot if it resolved to a function
		binop = n.cfunction
		if (binop.type == nBINARYOP && binop.op == DOT) {
			if (binop.rhs.type == nFUNCTION) {
				n.cfunction = binop.rhs
			}

			# Virtual methods
			if (binop.rhs.type == nVTAB_ACCESS) {
				var StringNode vtab_off = binop.rhs
				n.cfunction = BinaryOperationNode_new(
					vtab_off.ret_type, SQUARE_OPEN,
					BinaryOperationNode_new(Type_new(), SQUARE_OPEN,
						binop.lhs,
						StringNode_new(nNUMBER, Type_new(), "0").toNode()
					).toNode(),
					StringNode_new(nNUMBER, Type_new(), vtab_off.string).toNode()
				).toNode()
			}
		}

		# Inherit ret_type from function
		var RetNode rn = n.cfunction
		n.ret_type = rn.ret_type

		return n
	}

	func void visit(BinaryOperationNode n)(Scope prev_scope, StringNode sn,
																				 BinaryOperationNode binop, ListNode args,
																				 StringNode field,
																				 Node nn, Boolean fixargs, Number num) {
		# Handle fields
		if (n.op == DOT) {
			# Resolve first item
			sn = n.lhs
			n.lhs = sn.accept(this.v)

			# Save current scope
			prev_scope = this.scope

			# Set scope to that of the first items type
			sn = n.lhs
			sn.ret_type.resolve(this.scope)
			this.scope = sn.ret_type.getScope()
			if (this.scope == 0) this.scope = prev_scope

			# Resolve second item
			sn = n.rhs
			n.rhs = sn.accept(this.v)

			# Inherit ret_type from rhs
			sn = n.rhs
			n.ret_type = sn.ret_type

			# Restore scope
			this.scope = prev_scope

			return n
		}

		# Infer types
		if (n.op == ASSIGN)
		if (n.lhs.type == nIDENTIFIER) {
			field = n.lhs
			if (field.ret_type.raw == 1) {
				n.lhs = this.scope.resolve(field.string)
				field = n.lhs

				nn = n.rhs
				n.rhs = nn.accept(this.v)
				sn = n.rhs

				field.ret_type = sn.ret_type
			}
		}

		n.accept_children(this.v)

		return n
	}

	func void visit(ListNode n)() {
		if (n.type != nGLOBAL) {
			n.accept_children(this.v)
		}

		return n
	}

	# Must NOT resolve the children of the EnumNode
	# They are used raw in the Dump visitor to form the name lookup array
	func void visit(EnumNode n) {
		return n
	}
}
