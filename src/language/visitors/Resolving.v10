func Resolving Resolving_new()(Scope sc) {
	sc = scope
	var Visitor v = 0
	var res = Resolving_new(v, sc, true)
	res.v = res
	return res
}

class virtual Resolving < Visitor (Visitor v, Scope scope, Boolean resolve_idents) {
	func void visit(StringNode n)(Node replacement) {
		n.ret_type.resolve(this.scope)
		if (n.type == nIDENTIFIER) {
			if (this.resolve_idents == true) n = this.scope.resolve(n.string)
		}
		return n
	}

	func void visit(FunctionNode n)(Scope prev_scope, ListNode block) {
		prev_scope = this.scope
		this.scope = n.scope
		n.ret_type.resolve(this.scope)

		# Dont resolve identifiers in vars and args
		this.resolve_idents = false
		n.args.accept(this.v)
		n.vrbls.accept(this.v)
		this.resolve_idents = true
		n.block.accept(this.v)

		this.scope = prev_scope
		return n
	}

	func void visit(BinaryOperationNode n)(Scope prev_scope, StringNode sn,
																				 BinaryOperationNode binop, ListNode args,
																				 LinkedListNode lln, StringNode field,
																				 Node nn, Boolean fixargs, Number num) {
		# Handle fields
		if (n.op == DOT) {
			# Resolve first item
			sn = n.lhs
			n.lhs = sn.accept(this.v)

			# Save current scope
			prev_scope = this.scope

			# Set scope to that of the first items type
			sn = n.lhs
			sn.ret_type.resolve(this.scope)
			this.scope = sn.ret_type.getScope()
			if (this.scope == 0) this.scope = prev_scope

			# Resolve second item
			sn = n.rhs
			n.rhs = sn.accept(this.v)

			# Inherit ret_type from rhs
			sn = n.rhs
			n.ret_type = sn.ret_type

			# Restore scope
			this.scope = prev_scope

			return n
		}

		if (n.op == PAREN_OPEN) {
			# Target of arg fixing, default to normal function
			sn = n.lhs
			args = n.rhs

			# If a method, args fixing target is different
			if (n.lhs.type == nBINARYOP) {
				binop = n.lhs
				if (binop.op == DOT) {
					sn = binop.rhs
				}
			}

			# Resolve arguments
			n.rhs = args.accept(this.v)

			# Detect "pointer" methods, marked with m_
			fixargs = true
			if (sn.string < 1000) {
				fixargs = false
			} else {
				if (sn.string.get(0) == 'm')
				if (sn.string.get(1) == '_')
					fixargs = false
			}

			# Fix arguments into function name
			if (sn.type == nIDENTIFIER)
			if (fixargs == true) {
				# Extend function name
				sn.string = sn.string.clone(256)

				# Add args to function name
				lln = args.children.first
				loop {
					if (lln == 0) { break }
					field = lln.payload

					# Append type to function name
					if (field.ret_type.raw == 0) error("Unknown type in call to ", sn.string, "...")
					sn.string.append('_').append(field.ret_type.raw)

					lln = lln.fwrd
				}
			}

			# If LHS is a DOT, add its LHS to arguments (this)
			if (n.lhs.type == nBINARYOP) {
				binop = n.lhs
				if (binop.op == DOT) {
					sn = binop.rhs

					if (sn.type == nIDENTIFIER) {
						nn = binop.lhs
						nn = nn.accept(this.v)
						args.prepend(nn)
					}
				}
			}

			# Resolve function
			nn = n.lhs
			n.lhs = nn.accept(this.v)

			# Fix up dot if it resolved to a function
			binop = n.lhs
			if (n.lhs.type == nBINARYOP)
			if (binop.op == DOT) {
				if (binop.rhs.type == nFUNCTION) {
					n.lhs = binop.rhs
				}

				# Virtual methods
				if (binop.rhs.type == nVTAB_ACCESS) {
					var StringNode vtab_off = binop.rhs
					n.lhs = BinaryOperationNode_new(
						vtab_off.ret_type, SQUARE_OPEN,
						BinaryOperationNode_new(Type_new(), SQUARE_OPEN,
							binop.lhs,
							StringNode_new(nNUMBER, Type_new(), "0").toNode()
						).toNode(),
						StringNode_new(nNUMBER, Type_new(), vtab_off.string).toNode()
					).toNode()
				}
			}

			# Inherit ret_type from function
			sn = n.lhs
			n.ret_type = sn.ret_type

			return n
		}

		# Infer types
		if (n.op == ASSIGN)
		if (n.lhs.type == nIDENTIFIER) {
			field = n.lhs
			if (field.ret_type.raw == 1) {
				n.lhs = this.scope.resolve(field.string)
				field = n.lhs

				nn = n.rhs
				n.rhs = nn.accept(this.v)
				sn = n.rhs

				field.ret_type = sn.ret_type
			}
		}

		n.accept_children(this.v)

		return n
	}

	func void visit(ListNode n)() {
		if (n.type != nGLOBAL) {
			n.accept_children(this.v)
		}

		return n
	}
}
