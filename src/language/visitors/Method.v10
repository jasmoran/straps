func Method Method_new() {
	return Method_new(None<ListNode>, None<ClassNode>)
}

class virtual Method < Visitor (Option<ListNode> pb, Option<ClassNode> cls) {
	func Option<Node> visit(ClassNode n) {
		this.cls = Some(n)

		if (n.parent.is_some() == true) {
			var parent = n.parent.unwrap()

			# Resolve parent type
			parent.resolve(scope)

			if (parent.res.is_some() == true) {
				# Link scopes
				n.scope.parent = Some(parent.res.unwrap().scope)

				# Inherit vtable
				if (n.vtable.is_some() == true) {
					var par_vtab = parent.res.unwrap().vtable
					if (par_vtab.is_some() == true) {
						n.vtable = Some(par_vtab.unwrap().shallow_clone())
					}
				}
			}
		}

		# Process each method
		n.block.accept_children(this)

		# Remove methods from now class now they have been copied to parent block
		n.block.children.clear()
		this.cls = None<ClassNode>

  	return None<Node>
	}

	func Option<Node> visit(FunctionNode n)(Number length) {
		var pure = n.name.clone()
		n.pure = pure

		# Leave main function alone
		if (n.name.equal("main") == true) return None<Node>
		if (n.name.get(0) == '_') return None<Node>

		if (this.cls.is_some() == true) {
			# Add 'this' to arguments
			n.args.prepend(
				StringNode_new(nIDENTIFIER, n.position.clone("Method this"), Type_new(this.cls.unwrap().name), "this")
			)
		}

		n.name = String_new(256).append(n.name)
		var cls_scope_name = String_new(256).append(n.name)

		# Loop through arguments
		for (arg in n.args.children) {
			if (arg.type != nIDENTIFIER) error("Non identifier argument to function ", pure)
			var type = arg.to(StringNode).ret_type.raw

			# Append arguments type to function name
			n.name.append('_').append(type)

			if (arg != n.args.children.first.unwrap().payload) {
				cls_scope_name.append('_').append(type)
			}
		}

		if (this.cls.is_some() == true) {
			var cls = this.cls.unwrap()
			var clone = n.shallow_clone()

			if (cls.vtable.is_none() == true) {
				# Add method (direct) to scope of class
				cls.scope.set(pure, clone)
			} else {
				# Add method to vtable of class
				cls.vtable.unwrap().set(cls_scope_name, n)

				# Find method offset in vtable
				var offset = cls.vtable.unwrap().get_pos(cls_scope_name)
				offset << 3

				# Add method (via vtable) to scope of class
				var vtab = n.shallow_clone()
				vtab.type = nVTAB_ACCESS
				vtab.name = offset.toString()
				cls.scope.set(pure, vtab)
			}

			# Save new method name "_CLASS_METHOD"
			length = n.name.length
			length += 2
			n.name = cls.name.clone(length).prepend('_').append('_').append(n.name)
			clone.name = n.name

			# Copy method to parent block
			this.pb.expect("Attempted to append method outside of a block").append(n)
		}

  	return None<Node>
	}

	func Option<ListNode> visit(ListNode n) {
		var old_pb = this.pb
		if (n.type == nBLOCK)
			this.pb = Some(n)

		n.accept_children(this)

		this.pb = old_pb

  	return None<ListNode>
	}
}
