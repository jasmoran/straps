func Method Method_new()(?T, ListNode ln, ClassNode cn) {
	define V "Method"
	include "src/language/visitors/init.v10"
	ln = 0
	cn = 0
	v = Method_new(?U, ln, cn)
	v.v = v
	return v
}

class Method(?T, ListNode pb, ClassNode cls) {
	func void visit(ClassNode n)() {
		this.cls = n

		if (n.parent.raw != 0) {
			# Resolve parent type
			n.parent.resolve(scope)

			# Link scopes
			n.scope.parent = n.parent.res.scope

			# Inherit vtable
			if (n.vtable != 0) {
				var par_vtab = n.parent.res.vtable
				if (par_vtab != 0) {
					n.vtable = par_vtab.shallow_clone()
				}
			}
		}

		# Process each method
		n.block.visit_children(this.v)

		# Remove methods from now class now they have been copied to parent block
		n.block.children.clear()
		this.cls = 0

  	return 0
	}

	func void visit(FunctionNode n)(Number length, LinkedListNode lln, StringNode arg, FunctionNode clone) {
		# Leave main function alone
		if (n.name.equal("main") == true) return 0
		if (n.name.get(0) == '_') return 0

		if (this.cls != 0) {
			# Add 'this' to arguments
			n.args.prepend(
				StringNode_new(nIDENTIFIER, Type_new(this.cls.name), "this").toNode()
			)
		}

		n.name = String_new(256).append(n.name)
		var cls_scope_name = String_new(256).append(n.name)

		# Loop through arguments
		lln = n.args.children.first
		loop {
			if (lln == 0) { break }
			arg = lln.payload

			# Append arguments type to function name
			n.name.append('_').append(arg.ret_type.raw)

			if (lln != n.args.children.first) {
				cls_scope_name.append('_').append(arg.ret_type.raw)
			}

			lln = lln.fwrd
		}

		if (this.cls != 0) {
			clone = n.shallow_clone()

			if (this.cls.vtable == 0) {
				# Add method (direct) to scope of class
				this.cls.scope.set(cls_scope_name, clone.toNode())
			} else {
				# Add method to vtable of class
				var Any a = n
				this.cls.vtable.set(cls_scope_name, a)

				# Find method offset in vtable
				var offset = this.cls.vtable.get_pos(cls_scope_name)
				offset << 3

				# Add method (via vtable) to scope of class
				var Node nullnode = 0
				this.cls.scope.set(cls_scope_name, BinaryOperationNode_new(
					n.ret_type,
					SQUARE_OPEN,
					BinaryOperationNode_new(Type_new(), DOT,
						nullnode,
						StringNode_new(nIDENTIFIER, Type_new(), "vt").toNode()
					).toNode(),
					StringNode_new(nNUMBER, Type_new("Number"), offset.toString()).toNode()
				).toNode())
			}

			# Save new method name "_CLASS_METHOD"
			length = n.name.length
			length += 2
			n.name = this.cls.name.clone(length).prepend('_').append('_').append(n.name)
			clone.name = n.name

			# Copy method to parent block
			this.pb.append(n.toNode())
		}

  	return 0
	}

	func void visit(ListNode n)(ListNode old_pb) {
		old_pb = this.pb
		if (n.type == nBLOCK)
			this.pb = n

		n.visit_children(this.v)

		this.pb = old_pb

  	return 0
	}




	func void visit(Node n)() {
  	return 0
	}

	func void visit(BinaryOperationNode n)() {
		n.visit_children(this.v)
  	return 0
	}

	func void visit(UnaryOperationNode n)() {
		n.visit_children(this.v)
  	return 0
	}

	func void visit(StringNode n)() {
  	return 0
	}

	func void visit(IfNode n)() {
		n.visit_children(this.v)
  	return 0
	}

	func void visit(LoopNode n)() {
		n.visit_children(this.v)
  	return 0
	}

	func void visit(ReturnNode n)() {
		n.visit_children(this.v)
  	return 0
	}

	func void visit(EnumNode n)() {
		n.visit_children(this.v)
		return 0
	}
}
