func void printPos(Position pos, Number offset) {
	var mc = pos.start
	"{\"line\":".print()
	mc.get_line().toString().print()
	",\"character\":".print()
	var endChar = mc.get_column()
	endChar += offset
	endChar.toString().print()
	"}".print()
}

func void printRange(Position start, Position end, Number offset) {
	"- {\"file\":\"".print()
	start.stream.print()
	"\",\"start\":".print(STDOUT)
	printPos(start, 0)
	",\"end\":".print(STDOUT)
	printPos(end, offset)
}

func void printVar(String name, StringNode sn) {
	if (sn.ret_type.raw < 2) return 0
	"{\"name\":\"".print()
	name.print()
	"\",\"type\":\"".print()
	sn.ret_type.basicString().print()
	"\"},".print()
}

func void printFunc(String name, FunctionNode fn) {
	"{\"name\":\"".print()
	name.print()
	"\",\"type\":\"".print()
	fn.ret_type.basicString().print()
	"\",\"args\":[".print()

	for (narg in fn.args.children) {
		var StringNode arg = narg
		# Skip 'this' arg
		if (arg.string.equal("this") == true) next
		printVar(arg.string, arg)
	}

	"]}".print()
}

func void printFuncs(String name, ListNode fns) {
	for (nfn in fns.children) {
		var FunctionNode fn = nfn
		printFunc(name, fn)
		",".print()
	}
}

func void printScopeOptions(Map<String_Node> sc) {
	"\"options\":[".print()
	for (pair in sc) {
		var ListNode value = pair.value
		if (value.type == nBLOCK) {
			printFuncs(pair.key, value)
		} else {
			printVar(pair.key, value.to(StringNode))
		}
	}
	"]".print()
}

func void printNotMatch(RetNode lhs, RetNode rhs) {
	printRange(lhs.position, rhs.position, 0)
	",\"level\":\"warning\",\"message\":\"".print()
	rhs.ret_type.print(STDOUT)
	" does not match ".print()
	lhs.ret_type.print(STDOUT)
	"\"}".println()
}

func void printUnreturnable(ReturnNode n, Type fret_type) {
	var RetNode rn = n.expr
	printRange(n.position, rn.position, 0)
	",\"level\":\"warning\",\"message\":\"".print()
	rn.ret_type.print(STDOUT)
	" does not match return type ".print()
	fret_type.print(STDOUT)
	" of function\"}".println()
}

func void printUndefinedFunction(StringNode name, LinkedList<StringNode> args, Scope sc) {
	var ListNode options = sc.search(name.string)
	printRange(name.position, name.position, name.string.length)
	",\"level\":\"error\",\"message\":\"".print()
	if (options > 0 && options.type == nBLOCK) {
		"Given arguments don't match a defined function. Got ".print()
		for (arg in args) {
			arg.ret_type.basicString().print()
			" ".print()
		}
		"\",\"options\":[".print()
		printFuncs(name.string, options)
		"]".print()
	} else {
		if (options == 0) {
			"Could not resolve ".print()
			name.string.print()
		} else {
			# options.type != nBLOCK
			name.string.print()
			" is not a function".print()
		}
		"\",".print()
		printScopeOptions(sc.scope)
	}
	"}".println()
}

func void printUndefinedIdentifier(StringNode name, Scope sc) {
	var ListNode res = sc.search(name.string)
	printRange(name.position, name.position, name.string.length)
	",\"level\":\"error\",\"message\":\"".print()
	if (res <= 0) {
		"Could not resolve ".print()
		name.string.print()
		"\",".print()
		printScopeOptions(sc.scope)
	} else {
		name.string.print()
		" is a function".print()
		"\".\"options\":[".print()
		printFuncs(name.string, res)
		"]".print()
	}
	"}".println()
}