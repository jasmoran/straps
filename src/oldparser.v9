func asm_literal()() {
	token_consume(NASM)
	token_consume(PAREN_OPEN)
	token_load()
	token_rint(FILE)
	token_consume(STRING)
	token_consume(PAREN_CLOSE)
	return
}
enum NODE {
	nNASM nSYS nSTATEMENTS nPAREN_LIST nFUNCTION nRETURN nCOMPARISON nIF nNEXT nLOOP
	nBREAK nIDENTIFIER nENUM nCOMMENT nCHARACTER nSTRING nNUMBER nINDEX nCALL nOPERATION
}

func kernel_call()(register_ix) {
	token_consume(SYS)
	token_consume(PAREN_OPEN)

	var register_ix = 0

	loop {
		exression(1, 12, ident)

		# Write move instruction to stdout
		string_print(FILE, new_line)
		string_print(FILE, "mov ")

		# Write register to stdout
		array_get(registers[0], var register_ix)
		string_print(FILE, rax)
		var register_ix++

		string_print(FILE, ident)

		token_load()

		# Check for end of syscall
		if (token_tye[0] == PAREN_CLOSE) {
			break
		} else {
			token_consume(COMMA)
		}
	}

	token_consume(PAREN_CLOSE)

	# Write syscall instruction
	string_print(FILE, new_line)
	string_print(FILE, "syscall")
	string_print(FILE, new_line)

	return
}

func statements()() {
	loop {
		statement(0)
		if (rax == 0) { break }
	}
	return
}

func block()() {
	token_consume(CURLY_OPEN)
	statements()
	token_consume(CURLY_CLOSE)
	return
}

func fun_decl()(offset, string) {
	token_consume(FUNC)

	token_load()

	# Store function name in array
	string_clone(token)
	array_append(fun_names[0], rax)

	token_rint(FILE)
	token_consume(IDENTIFIER)

	# Write funion prologue to stdout
	string_print(FILE, ":")
	string_print(FILE, new_line)
	string_print(FILE, "push rbp")
	string_print(FILE, new_line)
	string_print(FILE, "mov rbp, rsp")
	string_print(FILE, new_line)
	string_print(FILE, "sub rsp, ")

	# Load arguments
	token_consume(PAREN_OPEN)
	token_load()
	var offset = 8
	if (token_tye[0] == PAREN_CLOSE) {
		token_consume(PAREN_CLOSE)
	} else {
		loop {
			var offset += 8

			var string = string_new(16)
			string_copy("QWORD[rbp+", var string)
			string_from_number(var offset, var string)
			string_join("]", var string)

			token_load()
			string_clone(token)
			map_set(local_vars[0], rax, var string)
			token_consume(IDENTIFIER)

			token_load()
			if (token_tye[0] == PAREN_CLOSE) {
				token_consume(PAREN_CLOSE)
				break
			}

			token_consume(COMMA)
		}
	}
	rax = var offset
	rax -= 8
	ret_size[0] = rax

	# Load variables
	token_consume(PAREN_OPEN)
	token_load()
	var offset = 0
	if (token_tye[0] == PAREN_CLOSE) {
		token_consume(PAREN_CLOSE)
	} else {
		loop {
			var offset += 8

			var string = string_new(16)
			string_copy("QWORD[rbp-", var string)
			string_from_number(var offset, var string)
			string_join("]", var string)

			token_load()
			string_clone(token)
			map_set(local_vars[0], rax, var string)
			token_consume(IDENTIFIER)


			token_load()
			if (token_tye[0] == PAREN_CLOSE) {
				token_consume(PAREN_CLOSE)
				break
			}

			token_consume(COMMA)
		}
	}
	printer_number(FILE, var offset)

	# Write new line to stdout
	string_print(FILE, new_line)

	block()

	map_clear(local_vars[0])

	# TODO: Warn that end of funion has been reached

	return
}


func fun_ret()() {
	token_consume(RETURN)


	exression(0, 12, ident)
	if (rax > 0) {
		string_print(FILE, new_line)
		string_print(FILE, "mov rax, ")
		string_print(FILE, ident)
	}

	# Write funion post to stdout
	string_print(FILE, new_line)
	string_print(FILE, "mov rsp, rbp")
	string_print(FILE, new_line)
	string_print(FILE, "pop rbp")
	string_print(FILE, new_line)
	string_print(FILE, "ret ")

	rax = ret_size[0]
	if (rax > 0) {
		printer_number(FILE, rax)
	}

	# Write new line to stdout
	string_print(FILE, new_line)

	return
}

func nt_if()(block_num, jump_type) {
	token_consume(IF)
	token_consume(PAREN_OPEN)

	exression(1, 12, ident)

	comarison()
	if (token_tye[0] == EQUAL) { var jump_type = "jne" token_consume(EQUAL) }
	if (token_tye[0] == NOT_EQUAL) { var jump_type = "je" token_consume(NOT_EQUAL) }
	if (token_tye[0] == GREATER) { var jump_type = "jng" token_consume(GREATER) }
	if (token_tye[0] == GREATER_EQ) { var jump_type = "jl" token_consume(GREATER_EQ) }
	if (token_tye[0] == LESS) { var jump_type = "jnl" token_consume(LESS) }
	if (token_tye[0] == LESS_EQ) { var jump_type = "jg" token_consume(LESS_EQ) }

	exression(1, 13, ident2)

	string_print(FILE, new_line)

	string_print(FILE, "cmp ")
	string_print(FILE, ident)
	string_print(FILE, ", ")
	string_print(FILE, ident2)

	token_consume(PAREN_CLOSE)

	# Write new line to stdout
	string_print(FILE, new_line)

	# Write jump type to stdout
	string_print(FILE, var jump_type)

	# Write end if label to stdout
	string_print(FILE, " .end_if_")

	# Reserve block id number
	var block_num = block_cnt[0]
	block_cnt[0]++
	printer_number(FILE, var block_num)

	# Write new line to stdout
	string_print(FILE, new_line)

	# IF block
	block()

	# Write new line to stdout
	string_print(FILE, new_line)

	token_load()

	if (token_tye[0] == ELSE) {
		token_consume(ELSE)

		# Write jmp to stdout
		string_print(FILE, "jmp .end_else_")
		printer_number(FILE, var block_num)

		# Write new line to stdout
		string_print(FILE, new_line)

		var jump_type = 1
	} else {
		var jump_type = 0
	}

	# Write end_if label to stdout
	string_print(FILE, ".end_if_")

	printer_number(FILE, var block_num)

	string_print(FILE, ":")
	string_print(FILE, new_line)

	rax = var jump_type
	if (rax == 1) {
		# ELSE block
		block()

		# Write new line to stdout
		string_print(FILE, new_line)

		# Write end if label to stdout
		string_print(FILE, ".end_else_")

		printer_number(FILE, var block_num)

		string_print(FILE, ":")
		string_print(FILE, new_line)
	}
	return
}

func loo_next()() {
	token_consume(NEXT)

	# Write jump to stdout
	string_print(FILE, "jmp .loop_")
	printer_number(FILE, enclosing_loo[0])

	# Write new line to stdout
	string_print(FILE, new_line)
	return
}

func loo()(block_num, old_block) {
	token_consume(LOOP)

	# Save enclosing loop value
	var old_block = enclosing_loo[0]

	# Reserve block id number
	var block_num = block_cnt[0]
	enclosing_loo[0] = var block_num
	block_cnt[0]++

	# Write label to stdout
	string_print(FILE, ".loop_")

	printer_number(FILE, var block_num)

	string_print(FILE, ":")
	string_print(FILE, new_line)

	block()

	# Write jump to stdout
	string_print(FILE, "jmp .loop_")
	printer_number(FILE, enclosing_loo[0])

	# Write new line to stdout
	string_print(FILE, new_line)

	# Write loop end label to stdout
	string_print(FILE, ".loop_end_")

	printer_number(FILE, var block_num)

	string_print(FILE, ":")
	string_print(FILE, new_line)

	# Write new line to stdout
	string_print(FILE, new_line)

	# Restore enclosing loop
	enclosing_loo[0] = var old_block

	return
}

func loo_break()() {
	token_consume(BREAK)
	# Write jump to stdout
	string_print(FILE, "jmp .loop_end_")
	printer_number(FILE, enclosing_loo[0])

	# Write new line to stdout
	string_print(FILE, new_line)
	return
}

func fun_call(fun_ident)() {
	token_consume(PAREN_OPEN)

	token_load()
	if (token_tye[0] == PAREN_CLOSE) {
		token_consume(PAREN_CLOSE)
	} else {
		loop {
			exression(1, 12, fun)

			string_print(FILE, new_line)

			string_print(FILE, "push ")
			string_print(FILE, fun)


			token_load()
			if (token_tye[0] == PAREN_CLOSE) {
				token_consume(PAREN_CLOSE)
				break
			}
			token_consume(COMMA)
		}
	}

	string_print(FILE, new_line)

	# Write to stdout
	string_print(FILE, "call ")

	# Write funion name to stdout
	string_print(FILE, var fun_ident)

	# Write new line to stdout
	string_print(FILE, new_line)

	string_copy("rax", var fun_ident)

	return
}

func nt_arg(out_str)() {
	token_consume(ARG)

	string_copy("QWORD[rbp + ", var out_str)

	token_load()
	read_number()
	rax++
	rax << 3
	string_from_number(rax, var out_str)
	token_consume(NUMBER)
	string_join("]", var out_str)
	return
}

func ariable(out_str)() {
	token_consume(VAR)
	token_load()
	map_get(local_vars[0], token)

	if (rax < 0) {
		string_print(STDERR, "Error: undefined variable ")
		string_print(STDERR, token)
		printer_line(STDERR)
		string_print(STDERR, new_line)
		printer_stack(STDERR)

		sys(60, 1)
	}

	string_copy(rax, var out_str)
	token_consume(IDENTIFIER)
	return
}

func identifier(out_str)() {
	string_copy(token, var out_str)
	token_consume(IDENTIFIER)
	return
}

func operation()(type, has_two_args) {
	# Get LHS
	assignable(1, 12, ident)
	if (rax == 0) {return}

	operator(0)
	if (rax == 0) {return 1}
	var type = rax

	if (rax == INCREMENT) {
		var has_two_args = 0
	} else {
		if (rax == DECREMENT) {
			var has_two_args = 0
		} else {
			var has_two_args = 1

			# Prepare RHS
			exression(1, 13, ident2)

			if (rax == 1) {
				string_print(FILE, new_line)
				string_print(FILE, "mov r13, ")
				string_print(FILE, ident2)
				string_copy("r13", ident2)
			}
		}
	}

	# Print operation
	string_print(FILE, new_line)

	if (var type == INCREMENT) { string_print(FILE, "inc ") }
	if (var type == DECREMENT) { string_print(FILE, "dec ") }
	if (var type == ASSIGN) {	string_print(FILE, "mov ") }
	if (var type == ADD) { string_print(FILE, "add ") }
	if (var type == SUB) { string_print(FILE, "sub ") }
	if (var type == SHIFTL) { string_print(FILE, "shl ") }
	if (var type == SHIFTR) { string_print(FILE, "shr ") }

	string_print(FILE, ident)

	if (var has_two_args == 1) {
		string_print(FILE, ", ")
		string_print(FILE, ident2)
	}

	string_print(FILE, new_line)

	return 1
}

func comarison()() {
	token_load()
	if (token_tye[0] == EQUAL) { return 1 }
	if (token_tye[0] == NOT_EQUAL) { return 1 }
	if (token_tye[0] == GREATER) { return 1 }
	if (token_tye[0] == GREATER_EQ) { return 1 }
	if (token_tye[0] == LESS) { return 1 }
	if (token_tye[0] == LESS_EQ) { return 1 }

	string_print(STDERR, "Error: expected token COMPARISON got token ")
	array_get(TOKEN, token_tye[0])
	string_print(STDERR, rax)
	printer_line(STDERR)
	string_print(STDERR, new_line)
	printer_stack(STDERR)

	sys(60,1)
	return
}

func operator(required)() {
	token_load()
	if (token_tye[0] == INCREMENT) { token_consume(INCREMENT) return INCREMENT }
	if (token_tye[0] == DECREMENT) { token_consume(DECREMENT) return DECREMENT }
	if (token_tye[0] == ASSIGN) {	token_consume(ASSIGN) return ASSIGN }
	if (token_tye[0] == ADD) { token_consume(ADD) return ADD }
	if (token_tye[0] == SUB) { token_consume(SUB) return SUB }
	if (token_tye[0] == SHIFTL) { token_consume(SHIFTL) return SHIFTL }
	if (token_tye[0] == SHIFTR) { token_consume(SHIFTR) return SHIFTR }

	if (var required == 1) {
		string_print(STDERR, "Error: expected token OPERATOR got token ")
		array_get(TOKEN, token_tye[0])
		string_print(STDERR, rax)
		printer_line(STDERR)
		string_print(STDERR, new_line)
		printer_stack(STDERR)

		sys(60, 1)
		return
	}

	return 0
}

func nt_include()(old_char_next, old_in_file_fid, old_line_number, old_column_number, old_file_name) {
	token_consume(INCLUDE)

	token_load()

	# Save char_next value
	rax = 0
	nasm("mov al, BYTE[char_next]")
	var old_char_next = rax

	# Save old in file
	var old_in_file_fid = in_file_fid[0]

	# Save line and column values
	var old_line_number = line_number[0]
	var old_column_number = column_number[0]
	line_number[0] = 1
	column_number[0] = 1

	# Save old file name
	var old_file_name = file_name[0]
	file_name[0] = string_clone(token)

	# Open new in file
	sys(2,token_image,0,511)
	in_file_fid[0] = rax

	# TODO: Ensure a string has been read

	# Initialize tokenizer
	nasm("mov BYTE[char_next], 1
	")
	token_kee_char()
	token_length[0] = 0

	statements()

	# Restore char_next value
	rax = var old_char_next
	nasm("mov BYTE[char_next], al")
	token_length[0] = 0

	# Restore old in file
	in_file_fid[0] = var old_in_file_fid

	# Restore line and column values
	line_number[0] = var old_line_number
	column_number[0] = var old_column_number

	# Restore old file name
	var old_file_name = file_name[0]

	return
}

func nt_enum()(ix, arr) {
	token_consume(ENUM)

	token_load()
	string_clone(token)
	array_append(enm_names[0], rax)
	token_consume(IDENTIFIER)

	token_consume(CURLY_OPEN)
	var ix = 0
	var arr = array_new(99)
	loop {
		token_load()

		if (token_tye[0] == CURLY_CLOSE) {
			token_consume(CURLY_CLOSE)
			break
		}

		string_print(FILE, "%define ")
		token_rint(FILE)
		string_clone(token)
		array_append(var arr, rax)
		token_consume(IDENTIFIER)
		string_print(FILE, " ")
		printer_number(FILE, var ix)
		string_print(FILE, new_line)

		var ix++
	}

	array_append(enm_items[0], var arr)

	return
}

func statement(required)() {
	operation(0)
	if (rax == 1) {return 1}

	# Check for break call
	if (token_tye[0] == BREAK) {
		loo_break()
		return 1
	}

	# Check for comment
	if (token_tye[0] == COMMENT) {
		token_consume(COMMENT)
		return 1
	}

	# Check for enum
	if (token_tye[0] == ENUM) {
		nt_enum()
		return 1
	}

	# TODO: add FOR

	# Check for funion declaration
	if (token_tye[0] == FUNC) {
		fun_decl()
		return 1
	}

	# Check for if declaration
	if (token_tye[0] == IF) {
		nt_if()
		return 1
	}

	# Check for include declaration
	if (token_tye[0] == INCLUDE) {
		nt_include()
		return 1
	}

	# Check for loop declaration
	if (token_tye[0] == LOOP) {
		loo()
		return 1
	}

	# Check for NASM section
	if (token_tye[0] == NASM) {
		asm_literal()
		return 1
	}

	# Check for next call
	if (token_tye[0] == NEXT) {
		loo_next()
		return 1
	}

	# Check for funion return
	if (token_tye[0] == RETURN) {
		fun_ret()
		return 1
	}

	# TODO: add SWITCH/CASE

	# Check for syscall
	if (token_tye[0] == SYS) {
		kernel_call()
		return 1
	}

	# TODO: add WHILE

	# Throw error if no match and one is required
	if (var required == 1) {
		string_print(STDERR, "Error: expected token STATEMENT got token ")
		array_get(TOKEN, token_tye[0])
		string_print(STDERR, rax)
		printer_line(STDERR)
		string_print(STDERR, new_line)
		printer_stack(STDERR)
		sys(60, 1)
	}

	return 0
}

func exression(out_str, reg_num)(type) {
	# type: 0 - no match, 1 - memory location, 2 - immediate value

	assignable(0, var reg_num, var out_str)
	if (rax > 0) { return }

	var type = 1

	# Check character
	if (token_tye[0] == CHARACTER) {
		string_copy(token, var out_str)
		token_consume(CHARACTER)
		var type = 2
	} else {

		# Check for string
		if (token_tye[0] == STRING) {
			# Store function name in array
			string_copy("str_", var out_str)
			array_length(strings[0])
			string_from_number(rax, var out_str)
			string_clone(token)
			array_append(strings[0], rax)
			token_consume(STRING)
		} else {

			# Check for number
			if (token_tye[0] == NUMBER) {
				string_copy(token, var out_str)
				token_consume(NUMBER)
				var type = 2
			} else {

				# Throw error if no match and one is required
				if (var out_str == 1) {
					string_print(STDERR, "Error: expected token EXPRESSION got token")
					array_get(TOKEN, token_tye[0])
					string_print(STDERR, rax)
					printer_line(STDERR)
					string_print(STDERR, new_line)
					printer_stack(STDERR)
					sys(60, 1)
				} else {
					return 0
				}
			}
		}
	}

	var type = index_and_call(var reg_num, var out_str, var type)

	return var type
}

func assignable(out_str, reg_num)(type) {
	# type: 0 - no match, 1 - memory location, 2 - immediate value

	token_load()

	var type = 1

	# Check for function argument
	if (token_tye[0] == ARG) {
		nt_arg(var out_str)
	} else {

		# Check for identifier
		if (token_tye[0] == IDENTIFIER) {
			identifier(var out_str)
			var type = 2
		} else {

			# Check for local variable
			if (token_tye[0] == VAR) {
				ariable(var out_str)
			} else {

				# Throw error if no match and one is required
				if (var reg_num == 1) {
					string_print(STDERR, "Error: expected token ASSIGNABLE got token")
					array_get(TOKEN, token_tye[0])
					string_print(STDERR, rax)
					printer_line(STDERR)
					string_print(STDERR, new_line)
					printer_stack(STDERR)
					sys(60, 1)
				} else {
					return 0
				}
			}
		}
	}

	var type = index_and_call(var reg_num, var out_str, var type)

	return var type
}

func index_and_call(type, out_str, reg_num)() {
	# type: 0 - no match, 1 - memory location, 2 - immediate value

	loop {
		token_load()

		if (token_tye[0] == SQUARE_OPEN) {
			token_consume(SQUARE_OPEN)

			if (var type != 2) {
				string_print(FILE, new_line)
				string_print(FILE, "mov r")
				printer_number(FILE, var reg_num)
				string_print(FILE, ", ")
				string_print(FILE, var out_str)
			}

			string_clear(indexing)
			string_join("QWORD[", indexing)

			if (var type == 2) {
				string_join(var out_str, indexing)
				var type = 1
			} else {
				string_join("r", indexing)
				string_from_number(var reg_num, indexing)
			}

			string_join(" + ", indexing)

			token_load()
			string_join(token, indexing)
			token_consume(NUMBER)

			token_consume(SQUARE_CLOSE)
			string_join("]", indexing)

			string_copy(indexing, var out_str)
		} else {

			if (token_tye[0] == PAREN_OPEN) {
				fun_call(var out_str)
			} else {
				return var type
			}
		}
	}
}

func list_func(out_stream)(ix, fun_name, len) {
	# Loop through functions
	var ix = 0
	loop {
		array_length(fun_names[0])
		if (var ix == rax) {
			break
		}

		string_print(var out_stream, "fun_")
		printer_number(var out_stream, var ix)
		string_print(var out_stream, ":")
		string_print(var out_stream, new_line)
		string_print(var out_stream, "dq ")
		var fun_name = array_get(fun_names[0], var ix)
		var len = string_length(var fun_name)
		printer_number(var out_stream, var len)
		string_print(var out_stream, ", ")
		printer_number(var out_stream, var len)
		string_print(var out_stream, new_line)
		string_print(var out_stream, "db ")
		string_print(var out_stream, quote)
		string_print(var out_stream, var fun_name)
		string_print(var out_stream, quote)
		string_print(var out_stream, new_line)

		var ix++
	}

	# Loop through functions in reverse
	string_print(var out_stream, "fun_list: dq ")
	var ix = array_length(fun_names[0])
	loop {
		if (var ix == 0) {
			break
		}
		var ix--
		array_get(fun_names[0], var ix)
		string_print(var out_stream, rax)
		string_print(var out_stream, ", fun_")
		printer_number(var out_stream, var ix)

		if (var ix == 0) {} else {
			string_print(var out_stream, ", ")
		}
	}
	string_print(var out_stream, new_line)

	return
}

func list_str(out_stream)(ix, fun_name, len) {
	# Loop through functions
	var ix = 0
	loop {
		array_length(strings[0])
		if (var ix == rax) {
			break
		}

		string_print(var out_stream, "str_")
		printer_number(var out_stream, var ix)
		string_print(var out_stream, ":")
		string_print(var out_stream, new_line)
		string_print(var out_stream, "dq ")
		var fun_name = array_get(strings[0], var ix)
		var len = string_length(var fun_name)
		printer_number(var out_stream, var len)
		string_print(var out_stream, ", ")
		printer_number(var out_stream, var len)
		string_print(var out_stream, new_line)
		string_print(var out_stream, "db ")
		string_print(var out_stream, quote)
		string_print(var out_stream, var fun_name)
		string_print(var out_stream, quote)
		string_print(var out_stream, new_line)

		var ix++
	}
	string_print(var out_stream, new_line)

	return
}

func list_enums(out_stream)(enm_ix, items, names, item_ix, name, name_len) {
	# Loop through enumerations
	var enm_ix = 0
	loop {
		if (var enm_ix == array_length(enm_names[0])) {
			break
		}

		# Loop through enum items
		var items = array_get(enm_items[0], var enm_ix)
		var names = array_get(enm_names[0], var enm_ix)

		var item_ix = 0
		loop {
			array_length(var items)
			if (var item_ix == rax) {
				break
			}

			var name = array_get(var items, var item_ix)
			var name_len = string_length(var name)

			string_print(var out_stream, var names)
			string_print(var out_stream, "_")
			printer_number(var out_stream, var item_ix)
			string_print(var out_stream, ":")
			string_print(var out_stream, new_line)
			string_print(var out_stream, "dq ")
			printer_number(var out_stream, var name_len)
			string_print(var out_stream, ", ")
			printer_number(var out_stream, var name_len)
			string_print(var out_stream, new_line)
			string_print(var out_stream, "db ")
			string_print(var out_stream, quote)
			string_print(var out_stream, var name)
			string_print(var out_stream, quote)
			string_print(var out_stream, new_line)

			var item_ix++
		}

		var name_len = array_length(var items)

		string_print(var out_stream, var names)
		string_print(var out_stream, ":")
		string_print(var out_stream, new_line)
		string_print(var out_stream, "dq ")
		printer_number(var out_stream, var name_len)
		string_print(var out_stream, ", ")
		printer_number(var out_stream, var name_len)

		var item_ix = 0
		loop {
			array_length(var items)
			if (var item_ix == rax) {
				break
			}

			string_print(var out_stream, ", ")
			string_print(var out_stream, var names)
			string_print(var out_stream, "_")
			printer_number(var out_stream, var item_ix)

			var item_ix++
		}
		string_print(var out_stream, new_line)

		var enm_ix++
	}

	return
}
