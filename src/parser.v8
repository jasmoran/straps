func asm_literal(0, 0) {
	call token_consume(NASM)
	call token_consume(PAREN_OPEN)
	call token_load()
	call token_rint(FILE)
	call token_consume(STRING)
	call token_consume(PAREN_CLOSE)
	return
}

func kernel_call(0, 1) {
	call token_consume(SYS)
	call token_consume(PAREN_OPEN)

	var1 = 0

	loop {
		call exression(1, 12, ident)

		# Write move instruction to stdout
		call string_print(FILE, new_line)
		call string_print(FILE, "mov ")

		# Write register to stdout
		call array_get(registers[0], var1)
		call string_print(FILE, rax)
		var1++

		call string_print(FILE, ident)

		call token_load()

		# Check for end of syscall
		if (token_tye[0] == PAREN_CLOSE) {
			break
		} else {
			call token_consume(COMMA)
		}
	}

	call token_consume(PAREN_CLOSE)

	# Write syscall instruction
	call string_print(FILE, new_line)
	call string_print(FILE, "syscall")
	call string_print(FILE, new_line)

	return
}

func statements(0, 0) {
	loop {
		call statement(0)
		if (rax == 0) { break }
	}
	return
}

func block(0, 0) {
	call token_consume(CURLY_OPEN)
	call statements()
	call token_consume(CURLY_CLOSE)
	return
}

func fun_decl(0, 0) {
	call token_consume(FUNC)

	call token_load()

	# Store function name in array
	call string_clone(token)
	call array_append(fun_names[0], rax)

	call token_rint(FILE)
	call token_consume(IDENTIFIER)

	call token_consume(PAREN_OPEN)
	call token_load()
	call read_number()
	rax << 3
	ret_size[0] = rax
	call token_consume(NUMBER)

	call token_consume(COMMA)

	# Write funion prologue to stdout
	call string_print(FILE, ":")
	call string_print(FILE, new_line)
	call string_print(FILE, "push rbp")
	call string_print(FILE, new_line)
	call string_print(FILE, "mov rbp, rsp")
	call string_print(FILE, new_line)
	call string_print(FILE, "sub rsp, ")

	call token_load()
	call read_number()
	rax << 3
	call printer_number(FILE, rax)
	call token_consume(NUMBER)

	call token_consume(PAREN_CLOSE)

	# Write new line to stdout
	call string_print(FILE, new_line)

	call block()

	# TODO: Warn that end of funion has been reached

	return
}


func fun_ret(0, 0) {
	call token_consume(RETURN)


	call exression(0, 12, ident)
	if (rax > 0) {
		call string_print(FILE, new_line)
		call string_print(FILE, "mov rax, ")
		call string_print(FILE, ident)
	}

	# Write funion post to stdout
	call string_print(FILE, new_line)
	call string_print(FILE, "mov rsp, rbp")
	call string_print(FILE, new_line)
	call string_print(FILE, "pop rbp")
	call string_print(FILE, new_line)
	call string_print(FILE, "ret ")

	rax = ret_size[0]
	if (rax > 0) {
		call printer_number(FILE, rax)
	}

	# Write new line to stdout
	call string_print(FILE, new_line)

	return
}

func nt_if(0, 2) {
	call token_consume(IF)
	call token_consume(PAREN_OPEN)

	call exression(1, 12, ident)

	call comarison()
	if (token_tye[0] == EQUAL) { var2 = "jne" call token_consume(EQUAL) }
	if (token_tye[0] == NOT_EQUAL) { var2 = "je" call token_consume(NOT_EQUAL) }
	if (token_tye[0] == GREATER) { var2 = "jng" call token_consume(GREATER) }
	if (token_tye[0] == GREATER_EQ) { var2 = "jl" call token_consume(GREATER_EQ) }
	if (token_tye[0] == LESS) { var2 = "jnl" call token_consume(LESS) }
	if (token_tye[0] == LESS_EQ) { var2 = "jg" call token_consume(LESS_EQ) }

	call exression(1, 13, ident2)

	call string_print(FILE, new_line)

	call string_print(FILE, "cmp ")
	call string_print(FILE, ident)
	call string_print(FILE, ", ")
	call string_print(FILE, ident2)

	call token_consume(PAREN_CLOSE)

	# Write new line to stdout
	call string_print(FILE, new_line)

	# Write jump type to stdout
	call string_print(FILE, var2)

	# Write end if label to stdout
	call string_print(FILE, " .end_if_")

	# Reserve block id number
	rax = block_cnt[0]
	var1 = rax
	block_cnt[0]++
	call printer_number(FILE, var1)

	# Write new line to stdout
	call string_print(FILE, new_line)

	# IF block
	call block()

	# Write new line to stdout
	call string_print(FILE, new_line)

	call token_load()

	if (token_tye[0] == ELSE) {
		call token_consume(ELSE)

		# Write jmp to stdout
		call string_print(FILE, "jmp .end_else_")
		call printer_number(FILE, var1)

		# Write new line to stdout
		call string_print(FILE, new_line)

		var2 = 1
	} else {
		var2 = 0
	}

	# Write end_if label to stdout
	call string_print(FILE, ".end_if_")

	call printer_number(FILE, var1)

	call string_print(FILE, ":")
	call string_print(FILE, new_line)

	rax = var2
	if (rax == 1) {
		# ELSE block
		call block()

		# Write new line to stdout
		call string_print(FILE, new_line)

		# Write end if label to stdout
		call string_print(FILE, ".end_else_")

		call printer_number(FILE, var1)

		call string_print(FILE, ":")
		call string_print(FILE, new_line)
	}
	return
}

func loo_next(0, 0) {
	call token_consume(NEXT)

	# Write jump to stdout
	call string_print(FILE, "jmp .loop_")
	call printer_number(FILE, enclosing_loo[0])

	# Write new line to stdout
	call string_print(FILE, new_line)
	return
}

func loo(0, 2) {
	call token_consume(LOOP)

	# Save enclosing loop value
	rax = enclosing_loo[0]
	var2 = rax

	# Reserve block id number
	rax = block_cnt[0]
	var1 = rax
	enclosing_loo[0] = rax
	block_cnt[0]++

	# Write label to stdout
	call string_print(FILE, ".loop_")

	call printer_number(FILE, var1)

	call string_print(FILE, ":")
	call string_print(FILE, new_line)

	call block()

	# Write jump to stdout
	call string_print(FILE, "jmp .loop_")
	call printer_number(FILE, enclosing_loo[0])

	# Write new line to stdout
	call string_print(FILE, new_line)

	# Write loop end label to stdout
	call string_print(FILE, ".loop_end_")

	call printer_number(FILE, var1)

	call string_print(FILE, ":")
	call string_print(FILE, new_line)

	# Write new line to stdout
	call string_print(FILE, new_line)

	# Restore enclosing loop
	r9 = var2
	enclosing_loo[0] = r9

	return
}

func loo_break(0, 0) {
	call token_consume(BREAK)
	# Write jump to stdout
	call string_print(FILE, "jmp .loop_end_")
	call printer_number(FILE, enclosing_loo[0])

	# Write new line to stdout
	call string_print(FILE, new_line)
	return
}

func fun_call(0, 0) {
	call token_consume(CALL)

	# Get funion name
	call token_load()
	call string_copy(token, fun)
	call token_consume(IDENTIFIER)

	call token_consume(PAREN_OPEN)

	call token_load()
	if (token_tye[0] == PAREN_CLOSE) {
		call token_consume(PAREN_CLOSE)
	} else {
		loop {
			call exression(1, 12, ident)

			call string_print(FILE, new_line)

			call string_print(FILE, "push ")
			call string_print(FILE, ident)


			call token_load()
			if (token_tye[0] == PAREN_CLOSE) {
				call token_consume(PAREN_CLOSE)
				break
			}
			call token_consume(COMMA)
		}
	}

	call string_print(FILE, new_line)

	# Write call to stdout
	call string_print(FILE, "call ")

	# Write funion name to stdout
	call string_print(FILE, fun)

	# Write new line to stdout
	call string_print(FILE, new_line)

	return
}

func nt_arg(1, 0) {
	call token_consume(ARG)

	call string_copy("QWORD[rbp + ", arg1)

	call token_load()
	call read_number()
	rax++
	rax << 3
	call string_from_number(rax, arg1)
	call token_consume(NUMBER)
	call string_join("]", arg1)
	return
}

func ariable(1, 0) {
	call token_consume(VAR)

	call string_copy("QWORD[rbp - ", arg1)

	call token_load()
	call read_number()
	rax << 3
	call string_from_number(rax, arg1)
	call token_consume(NUMBER)
	call string_join("]", arg1)
	return
}

func identifier(1, 0) {
	call string_copy(token, arg1)
	call token_consume(IDENTIFIER)
	return
}

func operation(0, 2) {
	# Get LHS
	call assignable(1, 12, ident)
	if (rax == 0) {return}

	call operator()
	var1 = rax

	if (rax == INCREMENT) {
		var2 = 0
	} else {
		if (rax == DECREMENT) {
			var2 = 0
		} else {
			var2 = 1

			# Prepare RHS
			call exression(1, 13, ident2)

			if (rax == 1) {
				call string_print(FILE, new_line)
				call string_print(FILE, "mov r13, ")
				call string_print(FILE, ident2)
				call string_copy("r13", ident2)
			}
		}
	}

	# Print operation
	call string_print(FILE, new_line)

	if (var1 == INCREMENT) { call string_print(FILE, "inc ") }
	if (var1 == DECREMENT) { call string_print(FILE, "dec ") }
	if (var1 == ASSIGN) {	call string_print(FILE, "mov ") }
	if (var1 == ADD) { call string_print(FILE, "add ") }
	if (var1 == SUB) { call string_print(FILE, "sub ") }
	if (var1 == SHIFTL) { call string_print(FILE, "shl ") }
	if (var1 == SHIFTR) { call string_print(FILE, "shr ") }

	call string_print(FILE, ident)

	if (var2 == 1) {
		call string_print(FILE, ", ")
		call string_print(FILE, ident2)
	}

	call string_print(FILE, new_line)

	return 1
}

func comarison(0, 0) {
	call token_load()
	if (token_tye[0] == EQUAL) { return 1 }
	if (token_tye[0] == NOT_EQUAL) { return 1 }
	if (token_tye[0] == GREATER) { return 1 }
	if (token_tye[0] == GREATER_EQ) { return 1 }
	if (token_tye[0] == LESS) { return 1 }
	if (token_tye[0] == LESS_EQ) { return 1 }

	call string_print(STDERR, "Error: expected token COMPARISON got token ")
	call printer_number(STDERR, token_tye[0])
	call printer_line(STDERR)
	call string_print(STDERR, new_line)
	call printer_stack(STDERR)

	sys(60,1)
	return
}

func operator(0, 0) {
	call token_load()
	if (token_tye[0] == INCREMENT) { call token_consume(INCREMENT) return INCREMENT }
	if (token_tye[0] == DECREMENT) { call token_consume(DECREMENT) return DECREMENT }
	if (token_tye[0] == ASSIGN) {	call token_consume(ASSIGN) return ASSIGN }
	if (token_tye[0] == ADD) { call token_consume(ADD) return ADD }
	if (token_tye[0] == SUB) { call token_consume(SUB) return SUB }
	if (token_tye[0] == SHIFTL) { call token_consume(SHIFTL) return SHIFTL }
	if (token_tye[0] == SHIFTR) { call token_consume(SHIFTR) return SHIFTR }

	call string_print(STDERR, "Error: expected token OPERATOR got token ")
	call printer_number(STDERR, token_tye[0])
	call printer_line(STDERR)
	call string_print(STDERR, new_line)
	call printer_stack(STDERR)

	sys(60,1)
	return
}

func nt_include(0,4) {
	call token_consume(INCLUDE)

	call token_load()

	# Save char_next value
	rax = 0
	nasm("mov al, BYTE[char_next]")
	var1 = rax

	# Save old in file
	rax = in_file_fid[0]
	var2 = rax

	# Save line and column values
	rax = line_number[0]
	var3 = rax
	rax = column_number[0]
	var4 = rax
	line_number[0] = 1
	column_number[0] = 1


	# Open new in file
	sys(2,token_image,0,511)
	in_file_fid[0] = rax

	# TODO: Ensure a string has been read

	# Initialize tokenizer
	nasm("mov BYTE[char_next], 1
	")
	call token_kee_char()
	token_length[0] = 0

	call statements()

	# Restore char_next value
	rax = var1
	nasm("mov BYTE[char_next], al")
	token_length[0] = 0

	# Restore old in file
	rax = var2
	in_file_fid[0] = rax

	# Restore line and column values
	rax = var3
	line_number[0] = rax
	rax = var4
	column_number[0] = rax

	return
}

func statement(1, 0) {
	call operation(0)
	if (rax == 1) {return 1}

	# Check for break call
	if (token_tye[0] == BREAK) {
		call loo_break()
		return 1
	}

	if (token_tye[0] == CALL) {
		call fun_call()
		return 1
	}

	# Check for comment
	if (token_tye[0] == COMMENT) {
		call token_consume(COMMENT)
		return 1
	}

	# TODO: add FOR

	# Check for funion declaration
	if (token_tye[0] == FUNC) {
		call fun_decl()
		return 1
	}

	# Check for if declaration
	if (token_tye[0] == IF) {
		call nt_if()
		return 1
	}

	# Check for include declaration
	if (token_tye[0] == INCLUDE) {
		call nt_include()
		return 1
	}

	# Check for loop declaration
	if (token_tye[0] == LOOP) {
		call loo()
		return 1
	}

	# Check for NASM section
	if (token_tye[0] == NASM) {
		call asm_literal()
		return 1
	}

	# Check for next call
	if (token_tye[0] == NEXT) {
		call loo_next()
		return 1
	}

	# Check for funion return
	if (token_tye[0] == RETURN) {
		call fun_ret()
		return 1
	}

	# TODO: add SWITCH/CASE

	# Check for syscall
	if (token_tye[0] == SYS) {
		call kernel_call()
		return 1
	}

	# TODO: add WHILE

	# Throw error if no match and one is required
	if (arg1 == 1) {
		call string_print(STDERR, "Error: expected token STATEMENT got token ")
		call printer_number(STDERR, token_tye[0])
		call printer_line(STDERR)
		call string_print(STDERR, new_line)
		call printer_stack(STDERR)
		sys(60,1)
	}

	return 0
}

func exression(3, 1) {
	# arg3 - required
	# arg2 - register number
	# arg1 - output string

	call assignable(0, arg2, arg1)
	if (rax > 0) { return }

	var1 = 1

	# Check funion call
	if (token_tye[0] == CALL) {
		call fun_call()
		call string_copy("rax", arg1)
	} else {

		# Check character
		if (token_tye[0] == CHARACTER) {
			call string_copy(token, arg1)
			call token_consume(CHARACTER)
			var1 = 2
		} else {

			# Check for string
			if (token_tye[0] == STRING) {
				# Store function name in array
				call string_copy("str_", arg1)
				call array_length(strings[0])
				call string_from_number(rax, arg1)
				call string_clone(token)
				call array_append(strings[0], rax)
				call token_consume(STRING)
			} else {

				# Check for number
				if (token_tye[0] == NUMBER) {
					call string_copy(token, arg1)
					call token_consume(NUMBER)
					var1 = 2
				} else {

					# Throw error if no match and one is required
					if (arg1 == 1) {
						call string_print(STDERR, "Error: expected token EXPRESSION got token")
						call printer_number(STDERR, token_tye[0])
						call printer_line(STDERR)
						call string_print(STDERR, new_line)
						call printer_stack(STDERR)
						sys(60,1)
					} else {
						return 0
					}
				}
			}
		}
	}

	call indices(arg2, arg1, var1)
	var1 = rax

	return var1
}

func assignable(2, 1) {
	# arg3 - required
	# arg2 - register number
	# arg1 - output string

	call token_load()

	var1 = 1

	# Check for function argument
	if (token_tye[0] == ARG) {
		call nt_arg(arg1)
	} else {

		# Check for identifier
		if (token_tye[0] == IDENTIFIER) {
			call identifier(arg1)
			var1 = 2
		} else {

			# Check for local variable
			if (token_tye[0] == VAR) {
				call ariable(arg1)
			} else {

				# Throw error if no match and one is required
				if (arg2 == 1) {
					call string_print(STDERR, "Error: expected token ASSIGNABLE got token")
					call printer_number(STDERR, token_tye[0])
					call printer_line(STDERR)
					call string_print(STDERR, new_line)
					call printer_stack(STDERR)
					sys(60,1)
				} else {
					return 0
				}
			}
		}
	}

	call indices(arg2, arg1, var1)
	var1 = rax

	return var1
}

func indices(2, 0) {
	# arg3 - register number
	# arg2 - output string
	# arg1 - 2 == immediate value

	loop {
		call token_load()

		if (token_tye[0] == SQUARE_OPEN) {
			call token_consume(SQUARE_OPEN)

			if (arg1 != 2) {
				call string_print(FILE, new_line)
				call string_print(FILE, "mov r")
				call printer_number(FILE, arg3)
				call string_print(FILE, ", ")
				call string_print(FILE, arg2)
			}

			call string_clear(indexing)
			call string_join("QWORD[", indexing)

			if (arg1 == 2) {
				call string_join(arg2, indexing)
				arg1 = 1
			} else {
				call string_join("r", indexing)
				call string_from_number(arg3, indexing)
			}

			call string_join(" + ", indexing)

			call token_load()
			call string_join(token, indexing)
			call token_consume(NUMBER)

			call token_consume(SQUARE_CLOSE)
			call string_join("]", indexing)

			call string_copy(indexing, arg2)
		} else {
			return arg1
		}
	}
}

func list_func(1, 3) {
	# Loop through functions
	var1 = 0
	loop {
		call array_length(fun_names[0])
		if (var1 == rax) {
			break
		}

		call string_print(arg1, "fun_")
		call printer_number(arg1, var1)
		call string_print(arg1, ":")
		call string_print(arg1, new_line)
		call string_print(arg1, "dq ")
		call array_get(fun_names[0], var1)
		var2 = rax
		call string_length(var2)
		var3 = rax
		call printer_number(arg1, var3)
		call string_print(arg1, ", ")
		call printer_number(arg1, var3)
		call string_print(arg1, new_line)
		call string_print(arg1, "db ")
		call string_print(arg1, quote)
		call string_print(arg1, var2)
		call string_print(arg1, quote)
		call string_print(arg1, new_line)

		var1++
	}

	# Loop through functions in reverse
	call string_print(arg1, "fun_list: dq ")
	call array_length(fun_names[0])
	var1 = rax
	loop {
		if (var1 == 0) {
			break
		}
		var1--
		call array_get(fun_names[0], var1)
		call string_print(arg1, rax)
		call string_print(arg1, ", fun_")
		call printer_number(arg1, var1)

		if (var1 == 0) {} else {
			call string_print(arg1, ", ")
		}
	}
	call string_print(arg1, new_line)

	return
}

func list_str(1, 3) {
	# Loop through functions
	var1 = 0
	loop {
		call array_length(strings[0])
		if (var1 == rax) {
			break
		}

		call string_print(arg1, "str_")
		call printer_number(arg1, var1)
		call string_print(arg1, ":")
		call string_print(arg1, new_line)
		call string_print(arg1, "dq ")
		call array_get(strings[0], var1)
		var2 = rax
		call string_length(var2)
		var3 = rax
		call printer_number(arg1, var3)
		call string_print(arg1, ", ")
		call printer_number(arg1, var3)
		call string_print(arg1, new_line)
		call string_print(arg1, "db ")
		call string_print(arg1, quote)
		call string_print(arg1, var2)
		call string_print(arg1, quote)
		call string_print(arg1, new_line)

		var1++
	}
	call string_print(arg1, new_line)

	return
}
