~
%define ANY 			 0
%define ARG 			 1
%define BREAK 		 2
%define CALL			 3
%define CASE			 4
%define ELSE			 5
%define FOR   		 6
%define FUNC			 7
%define IF				 8
%define LOOP			 9
%define NASM			 10
%define NEXT			 11
%define RETURN		 12
%define SWITCH		 13
%define SYS 			 14
%define VAR 			 15
%define WHILE 		 16
%define NUMBER		 17
%define IDENTIFIER 18
%define STRING		 19
%define PAREN_OPEN 20
%define PAREN_CLOSE 21
%define COMMA			 22
%define COMMENT		 23
%define CURLY_OPEN 24
%define CURLY_CLOSE 25
%define EQUAL			 26
%define NOT_EQUAL	 27
%define GREATER		 28
%define GREATER_EQ 29
%define LESS			 30
%define LESS_EQ		 31
%define ASSIGN		 32
%define CHARACTER	 33

section .bss
	current_char:	resb	1
	next_char:	resb	1
	ret_size:			resq	1
	block_cnt:		resq  1
	enclosing_loo:resq  1

	token_tye:		resq	1
	token_image:	resb	2048
	token_length:	resq	1

	funct:				resb 256
	funct_length:	resq 1
	ident:				resb 256
	ident_length:	resq 1

section .data
	registers:		db		'rax,', 'rdi,', 'rsi,', 'rdx,', 'r10,', 'r8, '
	mov_inst:			db		10, 'mov '
	sys_inst:			db		10, 'syscall', 10
	func_prolog:	db		':', 10, 'push rbp', 10, 'mov rbp, rsp', 10, 'sub rsp, ' ;33
	func_post:		db		10, 'mov rsp, rbp', 10, 'pop rbp', 10, 'ret ' ;26
	new_line:			db		10
	loop_label:   db    '.loop_'
	loop_end_label: db    '.loop_end_'
	end_if_label: db    '.end_if_'
	end_else_label: db    '.end_else_'
	colon:        db    ':', 10
	jmp:          db    'jmp '
	jne:          db    'jne '
	jng:					db		'jng '
	jnl:					db		'jnl '
	je:						db		'je  '
	jl:						db		'jl  '
	jg:						db		'jg  '
	cmp:          db    'cmp '
	push:         db    'push '
	call:         db    'call '
	comma:				db		', '
	arg_ebp:		db		'QWORD[rbp + '
	var_ebp:			db		'QWORD[rbp - '
	square_close:	db		']'
	error:				db		'Error: '
	inv_char:			db		'invalid character: ', 39
	quote:				db		39
	exp_token:		db		'expected token '
	got_token:		db		' got token '
	expres:				db		'EXPRESSION'
	stmt:					db		'STATEMENT'

section .text
global main
~

f asm_literal,0,0{
	(NASM)token_consume;
	(PAREN_OPEN)token_consume;
	()token_load;
	()token_rint;
	(STRING)token_consume;
	(PAREN_CLOSE)token_consume;
	r
}

f syscall,0,1{
	(SYS)token_consume;
	(PAREN_OPEN)token_consume;

	a v1 =0;

	l{
		# Write move instruction to stdout
		*1,1,mov_inst,5*

		a r9=v1 ;
		~
			shl r9, 2
			add r9, registers
		~

		# Write register to stdout
		*1,1,r9,4*

		~inc ~v1 ~
		~

		(1)exression;

		()token_load;

		# Check for end of syscall
		i QWORD[token_tye] = PAREN_CLOSE {
			b
		}{
			(COMMA)token_consume;
		}
	}

	(PAREN_CLOSE)token_consume;

	# Write syscall instruction
	*1,1,sys_inst,9*

	r
}

f read_number,0,0{
	a rax=0;
	a rbx=token_image;
	a rcx=10;
	a r11=0;
	a r12=QWORD[token_length];

	l{
		a r11b=BYTE[rbx];
		~
			inc rbx
			sub r11b, '0'
			mul rcx
			add al, r11b
			dec r12
		~
		i r12 = 0 {b}{}
	}
	r
}

f write_number,1,0{
	# rax/p1 - integer input
	# rcx - divisor
	# rdx - remainder
	# r12 - digit counter

	a rax=p1 ;
	a rcx=10;
	a r12=0;

	l{
		a rdx=0;
		~
			div rcx
			push rdx
			inc r12
		~

		# Check for EOF
		i rax = 0 {
			b
		}{}
	}

	l{
		~
			pop rax
			add rax, '0'
		~

		a BYTE[current_char]=al;

		# Write byte to stdout
		*1,1,current_char,1*

		~
			dec r12
		~

		# Exit loop if count has reached 0
		i r12 = 0 {
			b
		}{}
	}
	r
}

f statements,0,0{
	l{
		(0)statement;
		i rax = 0 { b }{}
	}
	r
}

f block,0,0{
	(CURLY_OPEN)token_consume;
	()statements;
	(CURLY_CLOSE)token_consume;
	r
}

f str_coy,3,0{
	a rsi = p1 ;
	a rdi = p2 ;
	a rcx = p3 ;
	~
		rep movsb
	~
	r
}

f func_decl,0,0{
	(FUNC)token_consume;

	()token_load;
	()token_rint;
	(IDENTIFIER)token_consume;

	(PAREN_OPEN)token_consume;
	()token_load;
	()read_number;
	~
		shl rax, 3
	~
	a [ret_size]=rax;
	(NUMBER)token_consume;

	(COMMA)token_consume;

	# Write function prologue to stdout
	*1,1,func_prolog,33*

	()token_load;
	()read_number;
	~
		shl rax, 3
	~
	(rax)write_number;
	(NUMBER)token_consume;

	(PAREN_CLOSE)token_consume;

	# TODO: Warn that end of function has been reached

	# Write new line to stdout
	*1,1,new_line,1*

	()block;

	r
}


f func_ret,0,0{
	(RETURN)token_consume;

	# Write function post to stdout
	*1,1,func_post,26*

	a rax = QWORD[ret_size];
	i rax > 0 {
		(rax)write_number;
	}{}

	# Write new line to stdout
	*1,1,new_line,1*

	r
}

f if,0,2{
	(IF)token_consume;
	(PAREN_OPEN)token_consume;

	# Write new line to stdout
	*1,1,new_line,1*

	# Write cmp to stdout
	*1,1,cmp,4*

	(1)exression;

	()comarison;
	i QWORD[token_tye]=EQUAL			{ a v2 = jne; }{}
	i QWORD[token_tye]=NOT_EQUAL	{ a v2 = je;  }{}
	i QWORD[token_tye]=GREATER		{ a v2 = jng; }{}
	i QWORD[token_tye]=GREATER_EQ	{ a v2 = jl;  }{}
	i QWORD[token_tye]=LESS				{ a v2 = jnl; }{}
	i QWORD[token_tye]=LESS_EQ		{ a v2 = jg;  }{}
	(ANY)token_consume;

	# Write comma to stdout
	*1,1,comma,2*

	(1)exression;

	(PAREN_CLOSE)token_consume;

	# Write new line to stdout
	*1,1,new_line,1*

	# Write jump type to stdout
	a r9,v2 ;
	*1,1,r9,4*

	# Write end if label to stdout
	*1,1,end_if_label,8*

	# Reserve block id number
	a rax=[block_cnt];
	a v1 =rax;
	~
	inc QWORD[block_cnt]
	~
	(v1 )write_number;

	# Write new line to stdout
	*1,1,new_line,1*

	# IF block
	()block;

	# Write new line to stdout
	*1,1,new_line,1*

	()token_load;

	i QWORD[token_tye]=ELSE {
		(ELSE)token_consume;

		# Write jmp to stdout
		*1,1,jmp,4*

		# Write end else label to stdout
		*1,1,end_else_label,10*

		(v1 )write_number;

		# Write new line to stdout
		*1,1,new_line,1*

		a v2 =1;
	}{
		a v2 =0;
	}

	# Write end_if label to stdout
	*1,1,end_if_label,8*

	(v1 )write_number;

	# Write colon to stdout
	*1,1,colon,2*

	a rax=v2 ;
	i rax = 1 {
		# ELSE block
		()block;

		# Write new line to stdout
		*1,1,new_line,1*

		# Write end if label to stdout
		*1,1,end_else_label,10*

		(v1 )write_number;

		# Write colon to stdout
		*1,1,colon,2*
	}{}
	r
}

f loo_next,0,0{
	(NEXT)token_consume;

	# Write jump to stdout
	*1,1,jmp,4*

	# Write loop label to stdout
	*1,1,loop_label,6*

	(QWORD[enclosing_loo])write_number;

	# Write new line to stdout
	*1,1,new_line,1*
	r
}

f loo,0,2{
	(LOOP)token_consume;

	# Save enclosing loop value
	a rax=[enclosing_loo];
	a v2 =rax;

	# Reserve block id number
	a rax=[block_cnt];
	a v1 =rax;
	a [enclosing_loo]=rax;
	~
		inc QWORD[block_cnt]
	~

	# Write label to stdout
	*1,1,loop_label,6*

	(v1 )write_number;

	# Write colon to stdout
	*1,1,colon,2*

	()block;

	# Write jump to stdout
	*1,1,jmp,4*

	# Write loop label to stdout
	*1,1,loop_label,6*

	(QWORD[enclosing_loo])write_number;

	# Write new line to stdout
	*1,1,new_line,1*

	# Write loop end label to stdout
	*1,1,loop_end_label,10*

	(v1 )write_number;

	# Write colon to stdout
	*1,1,colon,2*

	# Write new line to stdout
	*1,1,new_line,1*

	# Restore enclosing loop
	a r9=v2 ;
	a QWORD[enclosing_loo]=r9;

	r
}

f loo_break,0,0{
	(BREAK)token_consume;
	# Write jump to stdout
	*1,1,jmp,4*

	# Write loop label to stdout
	*1,1,loop_end_label,10*

	(QWORD[enclosing_loo])write_number;

	# Write new line to stdout
	*1,1,new_line,1*
	r
}

f function_call,0,0{
	(CALL)token_consume;

	# Get function name
	()token_load;
	a r12 = QWORD[token_length];
	(r12, funct, token_image)str_coy;
	a QWORD[funct_length], r12;
	(IDENTIFIER)token_consume;

	(PAREN_OPEN)token_consume;

	()token_load;
	i QWORD[token_tye] = PAREN_CLOSE {
		(PAREN_CLOSE)token_consume;
	}{
		l{
			# Write push to stdout
			*1,1,push,5*

			(1)exression;

			# Write new line to stdout
			*1,1,new_line,1*

			()token_load;
			i QWORD[token_tye] = PAREN_CLOSE {
				(PAREN_CLOSE)token_consume;
				b
			}{}
			(COMMA)token_consume;
		}
	}

	# Write call to stdout
	*1,1,call,5*

	# Write function name to stdout
	*1,1,funct,QWORD[funct_length]*

	# Write new line to stdout
	*1,1,new_line,1*

	r
}

f arg,0,1{
	(ARG)token_consume;


	()token_load;
	()read_number;
	~
		inc rax
		shl rax, 3
	~
	a v1 = rax;
	(NUMBER)token_consume;

	()token_load;
	i QWORD[token_tye] = ASSIGN {
		# Print mov instruction to stdout
		*1,1,mov_inst,5*
	}{}

	# Print 'QWORD[rbp + ' to stdout
	*1,1,arg_ebp,12*

	(v1 )write_number;

	# Print square close bracket
	*1,1,square_close,1*

	i QWORD[token_tye] = ASSIGN {
		()assignment;
	}{}

	r
}

f ariable,0,1{
	(VAR)token_consume;

	()token_load;
	()read_number;
	~
		shl rax, 3
	~
	a v1 = rax;
	(NUMBER)token_consume;

	()token_load;
	i QWORD[token_tye] = ASSIGN {
		# Print mov instruction to stdout
		*1,1,mov_inst,5*
	}{}

	# Print 'QWORD[rbp - ' to stdout
	*1,1,var_ebp,12*

	(v1 )write_number;

	# Print square close bracket
	*1,1,square_close,1*

	i QWORD[token_tye] = ASSIGN {
		()assignment;
	}{}

	r
}

f identifier,0,1{
	a r12 = QWORD[token_length];
	(r12, ident, token_image)str_coy;
	a QWORD[ident_length], r12;
	(IDENTIFIER)token_consume;

	()token_load;
	i QWORD[token_tye] = ASSIGN {
		# Print mov instruction to stdout
		*1,1,mov_inst,5*
	}{}

	# Print identifier
	*1,1,ident,QWORD[ident_length]*

	i QWORD[token_tye] = ASSIGN {
		()assignment;
	}{}

	r
}

f assignment,0,0{
	(ASSIGN)token_consume;

	# Write comma to stdout
	*1,1,comma,2*

	(1)exression;

	# Write new line to stdout
	*1,1,new_line,1*

	r
}

f comarison,0,0{
	()token_load;
	i QWORD[token_tye]=EQUAL			{ a rax = 1; r }{}
	i QWORD[token_tye]=NOT_EQUAL	{ a rax = 1; r }{}
	i QWORD[token_tye]=GREATER		{ a rax = 1; r }{}
	i QWORD[token_tye]=GREATER_EQ	{ a rax = 1; r }{}
	i QWORD[token_tye]=LESS				{ a rax = 1; r }{}
	i QWORD[token_tye]=LESS_EQ		{ a rax = 1; r }{}

	*1,2,error,7*
	*1,2,exp_token,15*
	(99)write_number;
	*1,2,got_token,11*
	(QWORD[token_tye])write_number;
	*1,2,new_line,1*

	*60,1*
	r
}

f statement,1,0{
	# TODO: expand
	(0)exression;
	i rax = 1 {r}{}

	# Check for break call
	i QWORD[token_tye], BREAK {
		()loo_break;
		a rax=1;
		r
	}{}

	# Check for comment
	i QWORD[token_tye] = COMMENT {
		(COMMENT)token_consume;
		a rax=1;
		r
	}{}

	# TODO: add FOR

	# Check for function declaration
	i QWORD[token_tye] = FUNC {
		()func_decl;
		a rax=1;
		r
	}{}

	# Check for if declaration
	i QWORD[token_tye] = IF {
		()if;
		a rax=1;
		r
	}{}

	# Check for loop declaration
	i QWORD[token_tye] = LOOP {
		()loo;
		a rax=1;
		r
	}{}

	# Check for NASM section
	i QWORD[token_tye] = NASM {
		()asm_literal;
		a rax=1;
		r
	}{}

	# Check for next call
	i QWORD[token_tye], NEXT {
		()loo_next;
		a rax=1;
		r
	}{}

	# Check for function return
	i QWORD[token_tye] = RETURN {
		()func_ret;
		a rax=1;
		r
	}{}

	# TODO: add SWITCH/CASE

	# Check for syscall
	i QWORD[token_tye] = SYS {
		()syscall;
		a rax=1;
		r
	}{}

	# TODO: add WHILE

	# Throw error if no match and one is required
	a r12, p1 ;
	i r12 = 1 {
		*1,2,error,7*
		*1,2,exp_token,15*
		*1,2,stmt,9*
		*1,2,got_token,11*
		(QWORD[token_tye])write_number;
		*1,2,new_line,1*
		*60,1*
	}{}

	a rax=0;
	r
}

f exression,1,0{
	()token_load;

	# Check for function argument
	i QWORD[token_tye] = ARG {
		()arg;
		a rax=1;
		r
	}{}

	# Check function call
	i QWORD[token_tye] = CALL {
		()function_call;
		a rax=1;
		r
	}{}

	# Check character
	i QWORD[token_tye] = CHARACTER {
		()token_rint;
		(CHARACTER)token_consume;
		a rax=1;
		r
	}{}

	# TODO: add STRING (print label and out string in data section)

	# Check for identifier
	i QWORD[token_tye] = IDENTIFIER {
		()identifier;
		a rax=1;
		r
	}{}

	# Check for number
	i QWORD[token_tye] = NUMBER {
		()token_rint;
		(NUMBER)token_consume;
		a rax=1;
		r
	}{}

	# Check for local variable
	i QWORD[token_tye] = VAR {
		()ariable;
		a rax=1;
		r
	}{}

	# Throw error if no match and one is required
	a r12, p1 ;
	i r12 = 1 {
		*1,2,error,7*
		*1,2,exp_token,15*
		*1,2,expres,10*
		*1,2,got_token,11*
		(QWORD[token_tye])write_number;
		*1,2,new_line,1*
		*60,1*
	}{}

	a rax=0;
	r
}

f main,0,0{
	# Initialize tokenizer
	a BYTE[next_char]=1;
	()token_kee_char;
	a QWORD[token_length]=0;

	()statements;

	~
	mov rsp, rbp
	pop rbp
	~
	*60,0*
}

# TOKENIZER
f token_kee_char,0,1{
	# Move next_char into image
	a rax=0;
	a al=BYTE[next_char];
	a v1 =rax;
	a rbx=QWORD[token_length];
	a BYTE[rbx + token_image]=al;
	~inc QWORD[token_length]~

	# TODO: Check for length > 256
	# TODO: Line counter

	i BYTE[next_char]=0 {
		a rax=0;
	}{
		# Load new next_char from stdin
		*0,0,next_char,1*

		i rax = 0 {
			a BYTE[next_char]=0;
		}{}

		# Return old next_char
		a rax=v1 ;
	}

	r
}

f token_eek_char,0,0{
	a rax=0;
	a al=BYTE[next_char];
	r
}

f token_rint,0,0{
	*1,1,token_image,QWORD[token_length]*
	r
}

f token_load,0,0{
	# Check previous token has been consumed
	i QWORD[token_length] = 0 {
		# Skip whitespace
		l{
			()token_kee_char;
			i rax = 0 {
				a QWORD[token_tye] = 0;
				r
			}{}
			i rax > ' ' {
				b
			}{
				a QWORD[token_length] = 0;
			}
		}

		i rax = 'a' {
			()token_arg;
			i rax = 1 {r}{}
		}{}

		i rax = 'b' {
			()token_break;
			i rax = 1 {r}{}
		}{}

		i rax = 'c' {
			()token_eek_char;

			i rax = 'a' {
				()token_kee_char;
				()token_eek_char;

				i rax = 'l' {
					()token_call;
					i rax = 1 {r}{}
				}{}

				i rax = 's' {
					()token_case;
					i rax = 1 {r}{}
				}{}
			}{}

			a rax=0;
		}{}

		i rax = 'e' {
			()token_else;
			i rax = 1 {r}{}
		}{}

		i rax = 'f' {
			()token_eek_char;

			i rax = 'o' {
				()token_for;
				i rax = 1 {r}{}
			}{}

			i rax = 'u' {
				()token_func;
				i rax = 1 {r}{}
			}{}

			a rax=0;
		}{}

		i rax = 'i' {
			()token_if;
			i rax = 1 {r}{}
		}{}

		i rax = 'l' {
			()token_loo;
			i rax = 1 {r}{}
		}{}

		i rax = 'n' {
			()token_eek_char;

			i rax = 'a' {
				()token_nasm;
				i rax = 1 {r}{}
			}{}

			i rax = 'e' {
				()token_next;
				i rax = 1 {r}{}
			}{}

			a rax=0;
		}{}

		i rax = 'r' {
			()token_return;
			i rax = 1 {r}{}
		}{}

		i rax = 's' {
			()token_eek_char;

			i rax = 'w' {
				()token_switch;
				i rax = 1 {r}{}
			}{}

			i rax = 'y' {
				()token_sys;
				i rax = 1 {r}{}
			}{}

			a rax=0;
		}{}

		i rax = 'v' {
			()token_ar;
			i rax = 1 {r}{}
		}{}

		i rax = 'w' {
			()token_while;
			i rax = 1 {r}{}
		}{}

		i rax = 34 {
			()token_string;
			i rax = 1 {r}{}
		}{}

		i rax = '#' {
			()token_comment;
			i rax = 1 {r}{}
		}{}

		i rax = 39 {
			()token_character;
			i rax = 1 {r}{}
		}{}

		i rax = '(' {
			a QWORD[token_tye]=PAREN_OPEN;
			r
		}{}

		i rax = ')' {
			a QWORD[token_tye]=PAREN_CLOSE;
			r
		}{}

		i rax = 123 {
			a QWORD[token_tye]=CURLY_OPEN;
			r
		}{}

		i rax = '}' {
			a QWORD[token_tye]=CURLY_CLOSE;
			r
		}{}

		i rax = ',' {
			a QWORD[token_tye]=COMMA;
			r
		}{}

		i rax = 60 {
			()token_eek_char;

			i rax = 61 {
				()token_kee_char;
				a QWORD[token_tye]=LESS_EQ;
			}{
				a QWORD[token_tye]=LESS;
			}
			r
		}{}

		i rax = 61 {
			()token_eek_char;

			i rax = 61 {
				()token_kee_char;
				a QWORD[token_tye]=EQUAL;
			}{
				a QWORD[token_tye]=ASSIGN;
			}
			r
		}{}

		i rax = 62 {
			()token_eek_char;

			i rax = 61 {
				()token_kee_char;
				a QWORD[token_tye]=GREATER_EQ;
			}{
				a QWORD[token_tye]=GREATER;
			}
			r
		}{}

		i rax < '0' {}{
			i rax > '9' {}{
				()token_number;
				i rax = 1 {r}{}
			}
		}

		i rax = 0 {
			a al=BYTE[token_image];
		}{}

		i rax < 'a' {}{
			i rax > 'z' {}{
				()token_identifier;
				i rax = 1 {r}{}
			}
		}

		i rax < 'A' {}{
			i rax > 'Z' {}{
				()token_identifier;
				i rax = 1 {r}{}
			}
		}

		*1,2,error,7*
		*1,2,inv_char,20*
		()token_rint;
		*1,2,quote,1*
		*1,2,new_line,1*

		*60,1*
	}{
		r
	}
}

f token_consume,1,0{
	()token_load;
	a r12 = p1 ;
	i r12 = ANY {
		a QWORD[token_tye] = 0;
		a QWORD[token_length] = 0;
		r
	}{}
	i r12 = QWORD[token_tye] {
		a QWORD[token_tye] = 0;
		a QWORD[token_length] = 0;
	}{
		*1,2,error,7*
		*1,2,exp_token,15*
		(r12)write_number;
		*1,2,got_token,11*
		(QWORD[token_tye])write_number;
		*1,2,new_line,1*

		*60,1*
	}

	r
}

f token_arg,0,0{
	()token_eek_char; i rax = 'r' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'g' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=ARG;
	a rax=1;
	r
}

f token_break,0,0{
	()token_eek_char; i rax = 'r' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'e' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'a' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'k' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=BREAK;
	a rax=1;
	r
}

f token_call,0,0{
	()token_eek_char; i rax = 'l' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'l' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=CALL;
	a rax=1;
	r
}

f token_case,0,0{
	()token_eek_char; i rax = 's' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'e' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=CASE;
	a rax=1;
	r
}

f token_else,0,0{
	()token_eek_char; i rax = 'l' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 's' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'e' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=ELSE;
	a rax=1;
	r
}

f token_for,0,0{
	()token_eek_char; i rax = 'o' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'r' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=FOR;
	a rax=1;
	r
}

f token_func,0,0{
	()token_eek_char; i rax = 'u' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'n' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'c' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=FUNC;
	a rax=1;
	r
}

f token_if,0,0{
	()token_eek_char; i rax = 'f' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=IF;
	a rax=1;
	r
}

f token_loo,0,0{
	()token_eek_char; i rax = 'o' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'o' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'p' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=LOOP;
	a rax=1;
	r
}

f token_nasm,0,0{
	()token_eek_char; i rax = 'a' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 's' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'm' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=NASM;
	a rax=1;
	r
}

f token_next,0,0{
	()token_eek_char; i rax = 'e' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'x' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 't' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=NEXT;
	a rax=1;
	r
}

f token_return,0,0{
	()token_eek_char; i rax = 'e' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 't' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'u' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'r' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'n' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=RETURN;
	a rax=1;
	r
}

f token_switch,0,0{
	()token_eek_char; i rax = 'w' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'i' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 't' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'c' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'h' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=SWITCH;
	a rax=1;
	r
}

f token_sys,0,0{
	()token_eek_char; i rax = 'y' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 's' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=SYS;
	a rax=1;
	r
}

f token_ar,0,0{
	()token_eek_char; i rax = 'a' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'r' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=VAR;
	a rax=1;
	r
}

f token_while,0,0{
	()token_eek_char; i rax = 'h' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'i' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'l' { ()token_kee_char; }{ a rax=0; r }
	()token_eek_char; i rax = 'e' { ()token_kee_char; }{ a rax=0; r }

	a QWORD[token_tye]=WHILE;
	a rax=1;
	r
}

f token_number,0,0{
	l{
		()token_eek_char;

		i rax < '0' {}{
			i rax > '9' {}{
				()token_kee_char;
				n
			}
		}

		b
	}

	a QWORD[token_tye]=NUMBER;
	a rax=1;
	r
}

f token_identifier,0,0{
	l{
		()token_eek_char;

		i rax < 'a' {}{
			i rax > 'z' {}{
				()token_kee_char;
				n
			}
		}

		i rax < 'A' {}{
			i rax > 'Z' {}{
				()token_kee_char;
				n
			}
		}

		i rax < '0' {}{
			i rax > '9' {}{
				()token_kee_char;
				n
			}
		}

		i rax = '_' {
			()token_kee_char;
			n
		}{}

		i rax = '[' {
			()token_kee_char;
			n
		}{}

		i rax = ']' {
			()token_kee_char;
			n
		}{}

		b
	}

	a QWORD[token_tye]=IDENTIFIER;
	a rax=1;
	r
}

f token_string,0,0{
	a QWORD[token_length]=0;

	l{
		()token_kee_char;

		i rax = 0 {
			b
		}{}

		i rax = 34 {
			b
		}{}

		i rax = '\\' {
			()token_kee_char;
		}{}
	}

	~
		dec QWORD[token_length]
	~

	a QWORD[token_tye]=STRING;
	a rax=1;
	r
}

f token_comment,0,0{
	a QWORD[token_length]=0;

	l{
		()token_kee_char;

		i rax = 0 {
			b
		}{}

		i rax = '#' {
			b
		}{}

		i rax = 10 {
			b
		}{}
	}

	~
		dec QWORD[token_length]
	~

	a QWORD[token_tye]=COMMENT;
	a rax=1;
	r
}

f token_character,0,0{
	()token_kee_char;

	i rax = '\\' {
		()token_kee_char;
	}{}

	()token_kee_char;

	i rax = 39 {}{
		a rax=0;
		r
	}

	a QWORD[token_tye]=CHARACTER;
	a rax=1;
	r
}
