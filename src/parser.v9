enum NODE {
	nNONE nNASM nSYS nSTATEMENTS nPAREN_LIST nFUNCTION nRETURN nCOMPARISON nIF
	nNEXT nLOOP nBREAK nIDENTIFIER nENUM nCOMMENT nCHARACTER nSTRING nNUMBER
	nINDEX nCALL nOPERATION nMEM_ACCESS nREGISTER nPUSH nPOP nCLASS nFIELD
}

func nt_nasm(parent)(node) {
	token_consume(NASM)
	token_consume(PAREN_OPEN)

	# Save instruction string
	token_load()
	string_length(token)
	var node = node_new(nNASM, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(STRING)

	token_consume(PAREN_CLOSE)
	return var node
}

func nt_sys(parent)(node, expr) {
	token_consume(SYS)
	token_consume(PAREN_OPEN)

	var node = node_new(nSYS, 0, var parent)
	loop {
		var expr = nt_expression(var node)
		node_children(var node)
		ll_append(rax, var expr)

		token_load()
		# Check for end of syscall
		if (token_tye[0] == PAREN_CLOSE) {
			break
		} else {
			token_consume(COMMA)
		}
	}

	token_consume(PAREN_CLOSE)
	return var node
}

func nt_statements(parent)(node, expr) {
	var node = node_new(nSTATEMENTS, 0, var parent)
	loop {
		var expr = nt_statement(var node)
		if (var expr == 0) { break }

		node_children(var node)
		ll_append(rax, var expr)
	}

	return var node
}

func nt_block(parent)(node) {
	token_consume(CURLY_OPEN)
	var node = nt_statements(var parent)
	token_consume(CURLY_CLOSE)
	return var node
}

func nt_paren_list(item_func, parent)(node, ident) {
	token_consume(PAREN_OPEN)

	var node = node_new(nPAREN_LIST, 0, var parent)

	token_load()
	if (token_tye[0] == PAREN_CLOSE) {
		token_consume(PAREN_CLOSE)
	} else {
		loop {
			var ident = var item_func(var node)
			node_children(var node)
			ll_append(rax, var ident)

			token_load()
			if (token_tye[0] == PAREN_CLOSE) {
				token_consume(PAREN_CLOSE)
				break
			}

			token_consume(COMMA)
		}
	}

	return var node
}

func nt_function(parent)(node, child) {
	token_consume(FUNC)

	# Save function name
	token_load()
	string_length(token)
	var node = node_new(nFUNCTION, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(IDENTIFIER)

	# Save arguments
	var child = nt_paren_list(var node, nt_decl_pair)
	node_children(var node)
	ll_append(rax, var child)

	# Save variables
	var child = nt_paren_list(var node, nt_decl_pair)
	node_children(var node)
	ll_append(rax, var child)

	# Save block
	var child = nt_block(var node)
	node_children(var node)
	ll_append(rax, var child)

	return var node
}

func nt_return(parent)(node, expr) {
	token_consume(RETURN)
	var node = node_new(nRETURN, 0, var parent)
	var expr = nt_expression(var node)
	node_children(var node)
	ll_append(rax, var expr)
	return var node
}

func nt_comparison(parent)(node, expr) {
	var node = node_new(nCOMPARISON, 0, var parent)

	# Save LHS
	var expr = nt_expression(var node)
	node_children(var node)
	ll_append(rax, var expr)

	# Save comparitor
	tc_comparitor(1)
	var node[8] = rax

	# Save RHS
	var expr = nt_expression(var node)
	node_children(var node)
	ll_append(rax, var expr)

	return var node
}

func nt_if(parent)(node, child) {
	token_consume(IF)

	var node = node_new(nIF, 0, var parent)

	# Save comparison
	token_consume(PAREN_OPEN)
	var child = nt_comparison(var node)
	node_children(var node)
	ll_append(rax, var child)
	token_consume(PAREN_CLOSE)

	# Save IF block
	var child = nt_block(var node)
	node_children(var node)
	ll_append(rax, var child)

	token_load()
	if (token_tye[0] == ELSE) {
		token_consume(ELSE)

		# Save ELSE block
		var child = nt_block(var node)
		node_children(var node)
		ll_append(rax, var child)
	}

	return var node
}

func nt_next(parent)() {
	token_consume(NEXT)
	return node_new(nNEXT, 0, var parent)
}

func nt_loop(parent)(node, child) {
	token_consume(LOOP)

	var node = node_new(nLOOP, 0, var parent)

	# Save block
	var child = nt_block(var node)
	node_children(var node)
	ll_append(rax, var child)

	return var node
}

func nt_break(parent)() {
	token_consume(BREAK)
	return node_new(nBREAK, 0, var parent)
}

func nt_identifier(parent)(node) {
	# Save identifier string
	token_load()
	string_length(token)
	var node = node_new(nIDENTIFIER, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(IDENTIFIER)

	return var node
}

func nt_variable(parent)(node) {
	var node = nt_identifier(var parent)

	# Check for indexes and calls
	loop {
		token_load()

		if (token_tye[0] == SQUARE_OPEN) {
			var node = nt_index(var node)
			next
		}
		if (token_tye[0] == PAREN_OPEN) {
			var node = nt_call(var node)
			next
		}
		if (token_tye[0] == DOT) {
			var node = nt_field(var node)
			next
		}
		break
	}

	# Check for operators
	var node = nt_operation(var node)

	return var node
}

func nt_include(parent)(node, old_char_next, old_in_file_fid, old_line_number, old_column_number, old_file_name) {
	token_consume(INCLUDE)

	token_load()

	# Save char_next value
	rax = 0
	nasm("mov al, BYTE[char_next]")
	var old_char_next = rax

	# Save old in file
	var old_in_file_fid = in_file_fid[0]

	# Save line and column values
	var old_line_number = line_number[0]
	var old_column_number = column_number[0]
	line_number[0] = 1
	column_number[0] = 1

	# Save old file name
	var old_file_name = file_name[0]
	file_name[0] = string_clone(token)

	# Open new in file
	sys(2,token_image,0,511)
	in_file_fid[0] = rax

	# TODO: Ensure a string has been read

	# Initialize tokenizer
	nasm("mov BYTE[char_next], 1
	")
	token_kee_char()
	token_length[0] = 0

	var node = nt_statements(var parent)

	# Restore char_next value
	rax = var old_char_next
	nasm("mov BYTE[char_next], al")
	token_length[0] = 0

	# Restore old in file
	in_file_fid[0] = var old_in_file_fid

	# Restore line and column values
	line_number[0] = var old_line_number
	column_number[0] = var old_column_number

	# Restore old file name
	var old_file_name = file_name[0]

	return var node
}

func nt_enum(parent)(node, ident) {
	token_consume(ENUM)

	# Save enum name string
	token_load()
	string_length(token)
	var node = node_new(nENUM, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(IDENTIFIER)

	token_consume(CURLY_OPEN)
	loop {
		token_load()

		if (token_tye[0] == CURLY_CLOSE) {
			token_consume(CURLY_CLOSE)
			break
		}

		var ident = nt_identifier(var node)
		node_children(var node)
		ll_append(rax, var ident)
	}

	return var node
}

func nt_comment(parent)(node) {
	# Save string
	token_load()
	string_length(token)
	var node = node_new(nCOMMENT, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(COMMENT)

	return var node
}

func nt_character(parent)(node) {
	# Save character
	token_load()

	# For escaped characters
	string_length(token)
	var node = node_new(nCHARACTER, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(CHARACTER)

	return var node
}

func nt_string(parent)(node) {
	# Save string
	token_load()
	string_length(token)
	var node = node_new(nSTRING, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(STRING)

	# Check for indexes
	var node = nt_index(var node)

	return var node
}

func nt_number(parent)(node) {
	# Save identifier string
	token_load()
	string_length(token)
	var node = node_new(nNUMBER, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(NUMBER)

	return var node
}

func nt_class(parent)(node, child) {
	token_consume(CLASS)

	# Save class name
	token_load()
	string_length(token)
	var node = node_new(nCLASS, rax, var parent)
	node_data(var node)
	string_copy(token, rax)
	token_consume(IDENTIFIER)

	# Save fields
	var child = nt_paren_list(var node, nt_decl_pair)
	node_children(var node)
	ll_append(rax, var child)

	return var node
}

func nt_decl_pair(parent)(node, type) {
	var type = nt_identifier(0)
	var node = nt_identifier(var parent)
	var node[40] = var type
	return var node
}

func nt_statement(parent)() {
	token_load()

	if (token_tye[0] == BREAK) {
		return nt_break(var parent)
	}

	if (token_tye[0] == CLASS) {
		return nt_class(var parent)
	}

	if (token_tye[0] == COMMENT) {
		return nt_comment(var parent)
	}

	if (token_tye[0] == ENUM) {
		return nt_enum(var parent)
	}

	# TODO: add FOR

	if (token_tye[0] == FUNC) {
		return nt_function(var parent)
	}

	if (token_tye[0] == IDENTIFIER) {
		return nt_variable(var parent)
	}

	if (token_tye[0] == IF) {
		return nt_if(var parent)
	}

	if (token_tye[0] == INCLUDE) {
		return nt_include(var parent)
	}

	if (token_tye[0] == LOOP) {
		return nt_loop(var parent)
	}

	if (token_tye[0] == NASM) {
		return nt_nasm(var parent)
	}

	if (token_tye[0] == NEXT) {
		return nt_next(var parent)
	}

	if (token_tye[0] == RETURN) {
		return nt_return(var parent)
	}

	# TODO: add SWITCH/CASE

	if (token_tye[0] == SYS) {
		return nt_sys(var parent)
	}

	# TODO: add WHILE

	return 0
}

func nt_expression(parent)() {
	token_load()

	if (token_tye[0] == CHARACTER) {
		return nt_character(var parent)
	}

	if (token_tye[0] == IDENTIFIER) {
		return nt_variable(var parent)
	}

	if (token_tye[0] == STRING) {
		return nt_string(var parent)
	}

	if (token_tye[0] == NUMBER) {
		return nt_number(var parent)
	}

	return 0
}

func nt_index(prev_node)(node, expr) {
	token_load()

	if (token_tye[0] != SQUARE_OPEN) {
		return var prev_node
	}

	# Create new node
	node_parent(var prev_node)
	var node = node_new(nINDEX, 0, rax)

	# Adopt prev_node
	node_adopt(var prev_node, var node)

	token_consume(SQUARE_OPEN)
	var expr = nt_number(var node)
	node_children(var node)
	ll_append(rax, var expr)
	token_consume(SQUARE_CLOSE)

	return var node
}

func nt_call(prev_node)(node, list) {
	token_load()

	if (token_tye[0] != PAREN_OPEN) {
		return var prev_node
	}

	# Create new node
	node_parent(var prev_node)
	var node = node_new(nCALL, 0, rax)

	# Adopt prev_node
	node_adopt(var prev_node, var node)

	var list = nt_paren_list(var node, nt_expression)
	node_children(var node)
	ll_append(rax, var list)

	return var node
}

func nt_field(prev_node)(node, expr) {
	token_load()

	if (token_tye[0] != DOT) {
		return var prev_node
	}

	# Create new node
	node_parent(var prev_node)
	var node = node_new(nFIELD, 0, rax)

	# Adopt prev_node
	node_adopt(var prev_node, var node)

	token_consume(DOT)
	var expr = nt_identifier(var node)
	node_children(var node)
	ll_append(rax, var expr)

	return var node
}

func nt_operation(prev_node)(node, operator, expr) {
	var operator = tc_operator(0)

	# Check if there is an operator
	if (var operator == 0) {
		return var prev_node
	}

	# Create new node
	node_parent(var prev_node)
	var node = node_new(nOPERATION, 0, rax)

	# Adopt prev_node
	node_adopt(var prev_node, var node)

	# Save operator
	var node[8] = var operator

	if (var operator != INCREMENT) {
		if (var operator != DECREMENT) {
			# Save RHS
			var expr = nt_expression(var node)
			node_children(var node)
			ll_append(rax, var expr)
		}
	}

	return var node
}
