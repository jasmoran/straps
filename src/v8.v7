nasm("
%define ARG 			 1
%define BREAK 		 2
%define CALL			 3
%define CASE			 4
%define ELSE			 5
%define FOR   		 6
%define FUNC			 7
%define IF				 8
%define LOOP			 9
%define NASM			 10
%define NEXT			 11
%define RETURN		 12
%define SWITCH		 13
%define SYS 			 14
%define VAR 			 15
%define WHILE 		 16
%define NUMBER		 17
%define IDENTIFIER 18
%define STRING		 19
%define PAREN_OPEN 20
%define PAREN_CLOSE 21
%define COMMA			 22
%define COMMENT		 23
%define CURLY_OPEN 24
%define CURLY_CLOSE 25
%define EQUAL			 26
%define NOT_EQUAL	 27
%define GREATER		 28
%define GREATER_EQ 29
%define LESS			 30
%define LESS_EQ		 31
%define ASSIGN		 32
%define CHARACTER	 33
%define INCLUDE		 34
%define NOT				 35
%define SHIFTL		 36
%define SHIFTR		 37
%define INCREMENT	 38
%define ADD				 39
%define PLUS			 40
%define DECREMENT	 41
%define SUB				 42
%define MINUS			 43
%define SQUARE_OPEN  44
%define SQUARE_CLOSE 45
")

nasm("
%define FILE			-1
%define STDOUT		1
%define STDERR		2
")

nasm("section .bss
	current_char:	resb	1
	char_next:	resb	1
	ret_size:			resq	1
	block_cnt:		resq  1
	enclosing_loo:resq  1

	token_tye:		resq	1

	token:
	token_length:	resq	1
	token_size:		resq	1
	token_image:	resb	2048

	fun:
	fun_length:	resq 1
	fun_size:		resq 1
	fun_data:		resb 256

	ident:
	ident_length:	resq 1
	ident_size:		resq 1
	ident_data:		resb 256

	in_file_fid:	resq 1
	out_file_fid:	resq 1
	line_number:	resq 1
	column_number:resq 1
	file_name:		resq 1
	fun_names:		resq 1
	strings:			resq 1
")

nasm("
section .data
	registers:		db		'rax,', 'rdi,', 'rsi,', 'rdx,', 'r10,', 'r8, '
	mov_inst:			db		10, 'mov '
	inc_inst:			db		10, 'inc '
	add_inst:			db		10, 'add '
	dec_inst:			db		10, 'dec '
	sub_inst:			db		10, 'sub '
	shl_inst:			db		10, 'shl '
	shr_inst:			db		10, 'shr '
	inst_sys:			db		10, 'syscall', 10
	fun_prolog:	db		':', 10, 'push rbp', 10, 'mov rbp, rsp', 10, 'sub rsp, ' ;33
	fun_post:		db		10, 'mov rsp, rbp', 10, 'pop rbp', 10, 'ret ' ;26
	new_line:			db		10
	label_loop:   db    '.loop_'
	label_loop_end: db    '.loop_end_'
	end_if_label: db    '.end_if_'
	end_else_label: db    '.end_else_'
	colon:        db    ':', 10
	jmp:          db    'jmp '
	jne:          db    'jne '
	jng:					db		'jng '
	jnl:					db		'jnl '
	je:						db		'je  '
	jl:						db		'jl  '
	jg:						db		'jg  '
	cmp:          db    'cmp '
	push:         db    'push '
	inst_call:		db    'call '
	comma:				db		', '
	inst_arg:		db		'QWORD[rbp + '
	inst_var:			db		'QWORD[rbp - '
	square_close:	db		']'
	error:				db		'Error: '
	inv_char:			db		'invalid character: ', 39
	quote:				db		39
	exp_token:		db		'expected token '
	got_token:		db		' got token '
	expres:				db		'EXPRESSION'
	stmt:					db		'STATEMENT'
	cmprsn:				db		'COMPARISON'
	on_line:			db		' on line '
	column:				db		' column '
	string_label:	db		'str_'
	fun_label:		db		'fun_'
	fun_list_str:	db		'fun_list: dq '
	label_dq:			db		'dq '
	label_db:			db		'db '
	sect_data:		db		'section .data', 10
	plus:					db		'+'

section .text
global main
")

func asm_literal(0, 0) {
	call token_consume(NASM)
	call token_consume(PAREN_OPEN)
	call token_load()
	call token_rint(FILE)
	call token_consume(STRING)
	call token_consume(PAREN_CLOSE)
	return
}

func kernel_call(0, 1) {
	call token_consume(SYS)
	call token_consume(PAREN_OPEN)

	var1 = 0

	loop {
		# Write move instruction to stdout
		call printer(FILE, mov_inst,5)

		r9 = var1
		nasm("
			shl r9, 2
			add r9, registers
		")

		# Write register to stdout
		call printer(FILE, r9,4)

		nasm("inc ")var1
		nasm("
		")

		call exression(1)

		call token_load()

		# Check for end of syscall
		if (QWORD[token_tye] == PAREN_CLOSE) {
			break
		} else {
			call token_consume(COMMA)
		}
	}

	call token_consume(PAREN_CLOSE)

	# Write syscall instruction
	call printer(FILE, inst_sys,9)

	return
}

func read_number(0, 0) {
	rax = 0
	rbx = token_image
	rcx = 10
	r11 = 0
	r12 = QWORD[token_length]

	loop {
		r11b = BYTE[rbx]
		nasm("
			inc rbx
			sub r11b, '0'
			mul rcx
			add al, r11b
			dec r12
		")
		if (r12 == 0) {break}
	}
	return
}

func statements(0, 0) {
	loop {
		call statement(0)
		if (rax == 0) { break }
	}
	return
}

func block(0, 0) {
	call token_consume(CURLY_OPEN)
	call statements()
	call token_consume(CURLY_CLOSE)
	return
}

func fun_decl(0, 0) {
	call token_consume(FUNC)

	call token_load()

	# Store function name in array
	call string_clone(token)
	call array_append(QWORD[fun_names], rax)

	call token_rint(FILE)
	call token_consume(IDENTIFIER)

	call token_consume(PAREN_OPEN)
	call token_load()
	call read_number()
	nasm("shl rax, 3")
	QWORD[ret_size] = rax
	call token_consume(NUMBER)

	call token_consume(COMMA)

	# Write funion prologue to stdout
	call printer(FILE, fun_prolog,33)

	call token_load()
	call read_number()
	nasm("shl rax, 3
	")
	call printer_number(FILE, rax)
	call token_consume(NUMBER)

	call token_consume(PAREN_CLOSE)

	# Write new line to stdout
	call printer(FILE, new_line,1)

	call block()

	# TODO: Warn that end of funion has been reached

	return
}


func fun_ret(0, 0) {
	call token_consume(RETURN)


	call printer(FILE, mov_inst, 5)
	call printer(FILE, registers, 4)

	call exression(0)
	if (rax == 0) {
		call printer(FILE, registers, 3)
	}

	# Write funion post to stdout
	call printer(FILE, fun_post,26)

	rax = QWORD[ret_size]
	if (rax > 0) {
		call printer_number(FILE, rax)
	}

	# Write new line to stdout
	call printer(FILE, new_line,1)

	return
}

func nt_if(0, 2) {
	call token_consume(IF)
	call token_consume(PAREN_OPEN)

	# Write new line to stdout
	call printer(FILE, new_line,1)

	# Write cmp to stdout
	call printer(FILE, cmp,4)

	call exression(1)

	call comarison()
	if (QWORD[token_tye] == EQUAL) { var2 = jne call token_consume(EQUAL) }
	if (QWORD[token_tye] == NOT_EQUAL) { var2 = je call token_consume(NOT_EQUAL) }
	if (QWORD[token_tye] == GREATER) { var2 = jng call token_consume(GREATER) }
	if (QWORD[token_tye] == GREATER_EQ) { var2 = jl call token_consume(GREATER_EQ) }
	if (QWORD[token_tye] == LESS) { var2 = jnl call token_consume(LESS) }
	if (QWORD[token_tye] == LESS_EQ) { var2 = jg call token_consume(LESS_EQ) }

	# Write comma to stdout
	call printer(FILE, comma,2)

	call exression(1)

	call token_consume(PAREN_CLOSE)

	# Write new line to stdout
	call printer(FILE, new_line,1)

	# Write jump type to stdout
	r9 = var2
	call printer(FILE, r9,4)

	# Write end if label to stdout
	call printer(FILE, end_if_label,8)

	# Reserve block id number
	rax = QWORD[block_cnt]
	var1 = rax
	nasm("
	inc QWORD[block_cnt]
	")
	call printer_number(FILE, var1)

	# Write new line to stdout
	call printer(FILE, new_line,1)

	# IF block
	call block()

	# Write new line to stdout
	call printer(FILE, new_line,1)

	call token_load()

	if (QWORD[token_tye] == ELSE) {
		call token_consume(ELSE)

		# Write jmp to stdout
		call printer(FILE, jmp,4)

		# Write end else label to stdout
		call printer(FILE, end_else_label,10)

		call printer_number(FILE, var1)

		# Write new line to stdout
		call printer(FILE, new_line,1)

		var2 = 1
	} else {
		var2 = 0
	}

	# Write end_if label to stdout
	call printer(FILE, end_if_label,8)

	call printer_number(FILE, var1)

	# Write colon to stdout
	call printer(FILE, colon,2)

	rax = var2
	if (rax == 1) {
		# ELSE block
		call block()

		# Write new line to stdout
		call printer(FILE, new_line,1)

		# Write end if label to stdout
		call printer(FILE, end_else_label,10)

		call printer_number(FILE, var1)

		# Write colon to stdout
		call printer(FILE, colon,2)
	}
	return
}

func loo_next(0, 0) {
	call token_consume(NEXT)

	# Write jump to stdout
	call printer(FILE, jmp,4)

	# Write loop label to stdout
	call printer(FILE, label_loop,6)

	call printer_number(FILE, QWORD[enclosing_loo])

	# Write new line to stdout
	call printer(FILE, new_line,1)
	return
}

func loo(0, 2) {
	call token_consume(LOOP)

	# Save enclosing loop value
	rax = QWORD[enclosing_loo]
	var2 = rax

	# Reserve block id number
	rax = QWORD[block_cnt]
	var1 = rax
	QWORD[enclosing_loo] = rax
	nasm("
		inc QWORD[block_cnt]
	")

	# Write label to stdout
	call printer(FILE, label_loop,6)

	call printer_number(FILE, var1)

	# Write colon to stdout
	call printer(FILE, colon,2)

	call block()

	# Write jump to stdout
	call printer(FILE, jmp,4)

	# Write loop label to stdout
	call printer(FILE, label_loop,6)

	call printer_number(FILE, QWORD[enclosing_loo])

	# Write new line to stdout
	call printer(FILE, new_line,1)

	# Write loop end label to stdout
	call printer(FILE, label_loop_end,10)

	call printer_number(FILE, var1)

	# Write colon to stdout
	call printer(FILE, colon,2)

	# Write new line to stdout
	call printer(FILE, new_line,1)

	# Restore enclosing loop
	r9 = var2
	QWORD[enclosing_loo] = r9

	return
}

func loo_break(0, 0) {
	call token_consume(BREAK)
	# Write jump to stdout
	call printer(FILE, jmp,4)

	# Write loop label to stdout
	call printer(FILE, label_loop_end,10)

	call printer_number(FILE, QWORD[enclosing_loo])

	# Write new line to stdout
	call printer(FILE, new_line,1)
	return
}

func fun_call(0, 0) {
	call token_consume(CALL)

	# Get funion name
	call token_load()
	call string_copy(token, fun)
	call token_consume(IDENTIFIER)

	call token_consume(PAREN_OPEN)

	call token_load()
	if (QWORD[token_tye] == PAREN_CLOSE) {
		call token_consume(PAREN_CLOSE)
	} else {
		loop {
			# Write push to stdout
			call printer(FILE, push,5)

			call exression(1)

			# Write new line to stdout
			call printer(FILE, new_line,1)

			call token_load()
			if (QWORD[token_tye] == PAREN_CLOSE) {
				call token_consume(PAREN_CLOSE)
				break
			}
			call token_consume(COMMA)
		}
	}

	# Write call to stdout
	call printer(FILE, inst_call,5)

	# Write funion name to stdout
	call string_print(FILE, fun)

	# Write new line to stdout
	call printer(FILE, new_line,1)

	return
}

func nt_arg(0, 2) {
	call token_consume(ARG)

	call token_load()
	call read_number()
	nasm("
		inc rax
		shl rax, 3
	")
	var1 = rax
	call token_consume(NUMBER)

	call operator_begin()
	var2 = rax

	# Print 'QWORD[rbp + ' to stdout
	call printer(FILE, inst_arg,12)

	call printer_number(FILE, var1)

	# Print square close bracket
	call printer(FILE, square_close,1)

	call operator_end(var2)

	return
}

func ariable(0, 2) {
	call token_consume(VAR)

	call token_load()
	call read_number()
	nasm("
		shl rax, 3
	")
	var1 = rax
	call token_consume(NUMBER)

	call operator_begin()
	var2 = rax

	# Print 'QWORD[rbp - ' to stdout
	call printer(FILE, inst_var,12)

	call printer_number(FILE, var1)

	# Print square close bracket
	call printer(FILE, square_close,1)

	call operator_end(var2)

	return
}

func identifier(0, 3) {
	call string_copy(token, ident)
	call token_consume(IDENTIFIER)

	call token_load()
	var3 = 0
	if (QWORD[token_tye] == SQUARE_OPEN) {
		call token_consume(SQUARE_OPEN)
		call token_load()
		call read_number()
		var1 = rax
		call token_consume(NUMBER)
		call token_consume(SQUARE_CLOSE)
		var3 = 1
	}

	call operator_begin()
	var2 = rax

	if (var3 == 1) {
		# Print 'QWORD['
		call printer(FILE, inst_arg, 6)
	}

	# Print identifier
	call string_print(FILE, ident)

	if (var3 == 1) {
		call printer(FILE, plus, 1)
		call printer_number(FILE, var1)
		call printer(FILE, square_close,1)
	}

	call operator_end(var2)

	return
}

func operator_begin(0, 0) {
	call token_load()

	if (QWORD[token_tye] == ASSIGN) {
		call token_consume(ASSIGN)
		call printer(FILE, mov_inst,5)
		rax = 1
		return
	}

	if (QWORD[token_tye] == INCREMENT) {
		call token_consume(INCREMENT)
		call printer(FILE, inc_inst,5)
		rax = 2
		return
	}

	if (QWORD[token_tye] == ADD) {
		call token_consume(ADD)
		call printer(FILE, add_inst,5)
		rax = 1
		return
	}

	if (QWORD[token_tye] == DECREMENT) {
		call token_consume(DECREMENT)
		call printer(FILE, dec_inst,5)
		rax = 2
		return
	}

	if (QWORD[token_tye] == SUB) {
		call token_consume(SUB)
		call printer(FILE, sub_inst,5)
		rax = 1
		return
	}

	if (QWORD[token_tye] == SHIFTL) {
		call token_consume(SHIFTL)
		call printer(FILE, shl_inst,5)
		rax = 1
		return
	}

	if (QWORD[token_tye] == SHIFTR) {
		call token_consume(SHIFTR)
		call printer(FILE, shr_inst,5)
		rax = 1
		return
	}

	rax = 0
	return
}

func operator_end(1, 0) {
	if (arg1 > 0) {
		if (arg1 == 1) {
			# Write comma to stdout
			call printer(FILE, comma,2)

			call exression(1)
		}

		# Write new line to stdout
		call printer(FILE, new_line,1)
	}

	return
}

func nt_include(0,4) {
	call token_consume(INCLUDE)

	call token_load()

	# Save char_next value
	rax = 0
	al = BYTE[char_next]
	var1 = rax

	# Save old in file
	rax = QWORD[in_file_fid]
	var2 = rax

	# Save line and column values
	rax = QWORD[line_number]
	var3 = rax
	rax = QWORD[column_number]
	var4 = rax
	QWORD[line_number] = 1
	QWORD[column_number] = 1


	# Open new in file
	sys(2,token_image,0,511)
	QWORD[in_file_fid] = rax

	# TODO: Ensure a string has been read

	# Initialize tokenizer
	BYTE[char_next] = 1
	call token_kee_char()
	QWORD[token_length] = 0

	call statements()

	# Restore char_next value
	rax = var1
	BYTE[char_next] = al
	QWORD[token_length] = 0

	# Restore old in file
	rax = var2
	QWORD[in_file_fid] = rax

	# Restore line and column values
	rax = var3
	QWORD[line_number] = rax
	rax = var4
	QWORD[column_number] = rax

	return
}

func comarison(0, 0) {
	call token_load()
	if (QWORD[token_tye] == EQUAL) { rax = 1 return }
	if (QWORD[token_tye] == NOT_EQUAL) { rax = 1 return }
	if (QWORD[token_tye] == GREATER) { rax = 1 return }
	if (QWORD[token_tye] == GREATER_EQ) { rax = 1 return }
	if (QWORD[token_tye] == LESS) { rax = 1 return }
	if (QWORD[token_tye] == LESS_EQ) { rax = 1 return }

	call printer(STDERR, error,7)
	call printer(STDERR, exp_token,15)
	call printer(STDERR, cmprsn, 10)
	call printer(STDERR, got_token,11)
	call printer_number(STDERR, QWORD[token_tye])
	call printer_line(STDERR)
	call printer(STDERR, new_line,1)
	call printer_stack(STDERR)

	sys(60,1)
	return
}

func statement(1, 0) {
	call exression(0)
	if (rax == 1) {return}

	# Check for break call
	if (QWORD[token_tye] == BREAK) {
		call loo_break()
		rax = 1
		return
	}

	# Check for comment
	if (QWORD[token_tye] == COMMENT) {
		call token_consume(COMMENT)
		rax = 1
		return
	}

	# TODO: add FOR

	# Check for funion declaration
	if (QWORD[token_tye] == FUNC) {
		call fun_decl()
		rax = 1
		return
	}

	# Check for if declaration
	if (QWORD[token_tye] == IF) {
		call nt_if()
		rax = 1
		return
	}

	# Check for include declaration
	if (QWORD[token_tye] == INCLUDE) {
		call nt_include()
		rax = 1
		return
	}

	# Check for loop declaration
	if (QWORD[token_tye] == LOOP) {
		call loo()
		rax = 1
		return
	}

	# Check for NASM section
	if (QWORD[token_tye] == NASM) {
		call asm_literal()
		rax = 1
		return
	}

	# Check for next call
	if (QWORD[token_tye] == NEXT) {
		call loo_next()
		rax = 1
		return
	}

	# Check for funion return
	if (QWORD[token_tye] == RETURN) {
		call fun_ret()
		rax = 1
		return
	}

	# TODO: add SWITCH/CASE

	# Check for syscall
	if (QWORD[token_tye] == SYS) {
		call kernel_call()
		rax = 1
		return
	}

	# TODO: add WHILE

	# Throw error if no match and one is required
	if (arg1 == 1) {
		call printer(STDERR, error,7)
		call printer(STDERR, exp_token,15)
		call printer(STDERR, stmt,9)
		call printer(STDERR, got_token,11)
		call printer_number(STDERR, QWORD[token_tye])
		call printer_line(STDERR)
		call printer(STDERR, new_line,1)
		call printer_stack(STDERR)
		sys(60,1)
	}

	rax = 0
	return
}

func exression(1, 0) {
	call token_load()

	# Check for funion argument
	if (QWORD[token_tye] == ARG) {
		call nt_arg()
		rax = 1
		return
	}

	# Check funion call
	if (QWORD[token_tye] == CALL) {
		call fun_call()
		rax = 1
		return
	}

	# Check character
	if (QWORD[token_tye] == CHARACTER) {
		call token_rint(FILE)
		call token_consume(CHARACTER)
		rax = 1
		return
	}

	# Check for string
	if (QWORD[token_tye] == STRING) {
		# Store function name in array
		call printer(FILE, string_label, 4)
		call array_length(QWORD[strings])
		call printer_number(FILE, rax)
		call string_clone(token)
		call array_append(QWORD[strings], rax)
		call token_consume(STRING)
		rax = 1
		return
	}

	# Check for identifier
	if (QWORD[token_tye] == IDENTIFIER) {
		call identifier()
		rax = 1
		return
	}

	# Check for number
	if (QWORD[token_tye] == NUMBER) {
		call token_rint(FILE)
		call token_consume(NUMBER)
		rax = 1
		return
	}

	# Check for local variable
	if (QWORD[token_tye] == VAR) {
		call ariable()
		rax = 1
		return
	}

	# Throw error if no match and one is required
	if (arg1 == 1) {
		call printer(STDERR, error,7)
		call printer(STDERR, exp_token,15)
		call printer(STDERR, expres,10)
		call printer(STDERR, got_token,11)
		call printer_number(STDERR, QWORD[token_tye])
		call printer_line(STDERR)
		call printer(STDERR, new_line,1)
		call printer_stack(STDERR)
		sys(60,1)
	}

	rax = 0
	return
}

func list_func(1, 3) {
	# Loop through functions
	var1 = 0
	loop {
		call array_length(QWORD[fun_names])
		if (var1 == rax) {
			break
		}

		call printer(arg1, fun_label, 4)
		call printer_number(arg1, var1)
		call printer(arg1, colon, 2)
		call printer(arg1, label_dq, 3)
		call array_get(QWORD[fun_names], var1)
		var2 = rax
		call string_length(var2)
		var3 = rax
		call printer_number(arg1, var3)
		call printer(arg1, comma, 2)
		call printer_number(arg1, var3)
		call printer(arg1, new_line, 1)
		call printer(arg1, label_db, 3)
		call printer(arg1, quote, 1)
		call string_print(arg1, var2)
		call printer(arg1, quote, 1)
		call printer(arg1, new_line, 1)

		rax = var1
		nasm("inc rax")
		var1 = rax
	}

	# Loop through functions in reverse
	call printer(arg1, fun_list_str, 13)
	call array_length(QWORD[fun_names])
	var1 = rax
	loop {
		if (var1 == 0) {
			break
		}
		rax = var1
		nasm("dec rax")
		var1 = rax
		call array_get(QWORD[fun_names], var1)
		call string_print(arg1, rax)
		call printer(arg1, comma, 2)
		call printer(arg1, fun_label, 4)
		call printer_number(arg1, var1)

		if (var1 == 0) {} else {
			call printer(arg1, comma, 2)
		}
	}
	call printer(arg1, new_line, 1)

	return
}

func list_str(1, 3) {
	# Loop through functions
	var1 = 0
	loop {
		call array_length(QWORD[strings])
		if (var1 == rax) {
			break
		}

		call printer(arg1, string_label, 4)
		call printer_number(arg1, var1)
		call printer(arg1, colon, 2)
		call printer(arg1, label_dq, 3)
		call array_get(QWORD[strings], var1)
		var2 = rax
		call string_length(var2)
		var3 = rax
		call printer_number(arg1, var3)
		call printer(arg1, comma, 2)
		call printer_number(arg1, var3)
		call printer(arg1, new_line, 1)
		call printer(arg1, label_db, 3)
		call printer(arg1, quote, 1)
		call string_print(arg1, var2)
		call printer(arg1, quote, 1)
		call printer(arg1, new_line, 1)

		rax = var1
		nasm("inc rax")
		var1 = rax
	}
	call printer(arg1, new_line, 1)

	return
}

func main(0, 3) {
	arg0 = 0

	# Open in file
	nasm("add rsi, 8")
	var1 = rsi
	rsi = QWORD[rsi]
	sys(2,rsi,0,511)
	QWORD[in_file_fid] = rax

	# Create out file
	rsi = var1
	nasm("add rsi, 8")
	rsi = QWORD[rsi]
	sys(85,rsi,511)
	QWORD[out_file_fid] = rax

	# Create array for function names
	call array_new(1024)
	QWORD[fun_names] = rax

	# Create array for string literals
	call array_new(1024)
	QWORD[strings] = rax

	# Initialize tokenizer
	BYTE[char_next] = 1
	call token_kee_char()
	QWORD[token_length] = 0
	QWORD[line_number] = 1
	QWORD[column_number] = 1

	call statements()

	# Write data section
	call printer(FILE, new_line, 1)
	call printer(FILE, sect_data, 14)
	call list_func(FILE)
	call list_str(FILE)

	nasm("
	mov rsp, rbp
	pop rbp
	")
	sys(60,0)
}

# TOKENIZER
func token_kee_char(0, 1) {
	# Move char_next into image
	rax = 0
	al = BYTE[char_next]
	var1 = rax
	rbx = QWORD[token_length]
	nasm("add rbx, token_image")
	BYTE[rbx] = al
	nasm("inc QWORD[token_length]
	inc QWORD[column_number]")

	# TODO: Check for length > 256
	if (BYTE[char_next] == 10) {
		nasm("inc QWORD[line_number]")
		QWORD[column_number] = 1
	}

	if (BYTE[char_next] == 0) {
		rax = 0
	} else {
		# Load new char_next from stdin
		sys(0, QWORD[in_file_fid], char_next, 1)

		if (rax == 0) {
			BYTE[char_next] = 0
		}

		# Return old char_next
		rax = var1
	}

	return
}

func token_eek_char(0, 0) {
	rax = 0
	al = BYTE[char_next]
	return
}

func token_rint(1, 0) {
	call printer(arg1, token_image,QWORD[token_length])
	return
}

func token_load(0, 0) {
	# Check previous token has been consumed
	if (QWORD[token_length] == 0) {
		# Skip whitespace
		loop {
			call token_kee_char()
			if (rax == 0) {
				QWORD[token_tye] = 0
				return
			}
			if (rax > ' ') {
				break
			} else {
				QWORD[token_length] = 0
			}
		}

		if (rax == 'a') {
			call token_arg()
			if (rax == 1) {return}
		}

		if (rax == 'b') {
			call token_break()
			if (rax == 1) {return}
		}

		if (rax == 'c') {
			call token_eek_char()

			if (rax == 'a') {
				call token_kee_char()
				call token_eek_char()

				if (rax == 'l') {
					call token_call()
					if (rax == 1) {return}
				}

				if (rax == 's') {
					call token_case()
					if (rax == 1) {return}
				}
			}

			rax = 0
		}

		if (rax == 'e') {
			call token_else()
			if (rax == 1) {return}
		}

		if (rax == 'f') {
			call token_eek_char()

			if (rax == 'o') {
				call token_for()
				if (rax == 1) {return}
			}

			if (rax == 'u') {
				call token_func()
				if (rax == 1) {return}
			}

			rax = 0
		}

		if (rax == 'i') {
			call token_eek_char()

			if (rax == 'f') {
				call token_if()
				if (rax == 1) {return}
			}

			if (rax == 'n') {
				call token_include()
				if (rax == 1) {return}
			}

			rax = 0
		}

		if (rax == 'l') {
			call token_loo()
			if (rax == 1) {return}
		}

		if (rax == 'n') {
			call token_eek_char()

			if (rax == 'a') {
				call token_nasm()
				if (rax == 1) {return}
			}

			if (rax == 'e') {
				call token_next()
				if (rax == 1) {return}
			}

			rax = 0
		}

		if (rax == 'r') {
			call token_return()
			if (rax == 1) {return}
		}

		if (rax == 's') {
			call token_eek_char()

			if (rax == 'w') {
				call token_switch()
				if (rax == 1) {return}
			}

			if (rax == 'y') {
				call token_sys()
				if (rax == 1) {return}
			}

			rax = 0
		}

		if (rax == 'v') {
			call token_ar()
			if (rax == 1) {return}
		}

		if (rax == 'w') {
			call token_while()
			if (rax == 1) {return}
		}

		if (rax == 34) {
			call token_string()
			if (rax == 1) {return}
		}

		if (rax == '#') {
			call token_comment()
			if (rax == 1) {return}
		}

		if (rax == 39) {
			call token_character()
			if (rax == 1) {return}
		}

		if (rax == '(') {
			QWORD[token_tye] = PAREN_OPEN
			return
		}

		if (rax == ')') {
			QWORD[token_tye] = PAREN_CLOSE
			return
		}

		if (rax == 123) {
			QWORD[token_tye] = CURLY_OPEN
			return
		}

		if (rax == '}') {
			QWORD[token_tye] = CURLY_CLOSE
			return
		}

		if (rax == '[') {
			QWORD[token_tye] = SQUARE_OPEN
			return
		}

		if (rax == ']') {
			QWORD[token_tye] = SQUARE_CLOSE
			return
		}

		if (rax == ',') {
			QWORD[token_tye] = COMMA
			return
		}

		if (rax == '!') {
			call token_eek_char()

			if (rax == '=') {
				call token_kee_char()
				QWORD[token_tye] = NOT_EQUAL
			} else {
				QWORD[token_tye] = NOT
			}
			return
		}

		if (rax == 60) {
			call token_eek_char()

			if (rax == 61) {
				call token_kee_char()
				QWORD[token_tye] = LESS_EQ
				return
			}

			if (rax == 60) {
				call token_kee_char()
				QWORD[token_tye] = SHIFTL
				return
			}

			QWORD[token_tye] = LESS
			return
		}

		if (rax == 61) {
			call token_eek_char()

			if (rax == 61) {
				call token_kee_char()
				QWORD[token_tye] = EQUAL
			} else {
				QWORD[token_tye] = ASSIGN
			}
			return
		}

		if (rax == 62) {
			call token_eek_char()

			if (rax == 61) {
				call token_kee_char()
				QWORD[token_tye] = GREATER_EQ
				return
			}

			if (rax == 62) {
				call token_kee_char()
				QWORD[token_tye] = SHIFTR
				return
			}

			QWORD[token_tye] = GREATER
			return
		}

		if (rax == '+') {
			call token_eek_char()

			if (rax == '+') {
				call token_kee_char()
				QWORD[token_tye] = INCREMENT
				return
			}

			if (rax == '=') {
				call token_kee_char()
				QWORD[token_tye] = ADD
				return
			}

			QWORD[token_tye] = PLUS
			return
		}

		if (rax == '-') {
			call token_eek_char()

			if (rax == '-') {
				call token_kee_char()
				QWORD[token_tye] = DECREMENT
				return
			}

			if (rax == '=') {
				call token_kee_char()
				QWORD[token_tye] = SUB
				return
			}

			QWORD[token_tye] = MINUS
			return
		}

		if (rax >= '0') {
			if (rax <= '9') {
				call token_number()
				if (rax == 1) {return}
			}
		}

		if (rax == 0) {
			al = BYTE[token_image]
		}

		if (rax >= 'a') {
			if (rax <= 'z') {
				call token_identifier()
				if (rax == 1) {return}
			}
		}

		if (rax >= 'A') {
			if (rax <= 'Z') {
				call token_identifier()
				if (rax == 1) {return}
			}
		}

		call printer(STDERR, error,7)
		call printer(STDERR, inv_char,20)
		call token_rint(STDERR)
		call printer(STDERR, quote,1)
		call printer_line(2)
		call printer(STDERR, new_line,1)
		call printer_stack(STDERR)

		sys(60,1)
	} else {
		return
	}
}

func token_consume(1, 0) {
	call token_load()
	r12 = arg1
	if (r12 == QWORD[token_tye]) {
		QWORD[token_tye] = 0
		QWORD[token_length] = 0
	} else {
		call printer(STDERR, error,7)
		call printer(STDERR, exp_token,15)
		call printer_number(STDERR, r12)
		call printer(STDERR, got_token,11)
		call printer_number(STDERR, QWORD[token_tye])
		call printer_line(STDERR)
		call printer(STDERR, new_line,1)
		call printer_stack(STDERR)

		sys(60,1)
	}

	return
}

func token_arg(0, 0) {
	call token_eek_char() if (rax == 'r') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'g') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = ARG
	rax = 1
	return
}

func token_break(0, 0) {
	call token_eek_char() if (rax == 'r') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'a') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'k') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = BREAK
	rax = 1
	return
}

func token_call(0, 0) {
	call token_eek_char() if (rax == 'l') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'l') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = CALL
	rax = 1
	return
}

func token_case(0, 0) {
	call token_eek_char() if (rax == 's') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = CASE
	rax = 1
	return
}

func token_else(0, 0) {
	call token_eek_char() if (rax == 'l') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 's') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = ELSE
	rax = 1
	return
}

func token_for(0, 0) {
	call token_eek_char() if (rax == 'o') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'r') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = FOR
	rax = 1
	return
}

func token_func(0, 0) {
	call token_eek_char() if (rax == 'u') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'n') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'c') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = FUNC
	rax = 1
	return
}

func token_if(0, 0) {
	call token_eek_char() if (rax == 'f') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = IF
	rax = 1
	return
}

func token_include(0, 0) {
	call token_eek_char() if (rax == 'n') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'c') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'l') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'u') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'd') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = INCLUDE
	rax = 1
	return
}

func token_loo(0, 0) {
	call token_eek_char() if (rax == 'o') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'o') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'p') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = LOOP
	rax = 1
	return
}

func token_nasm(0, 0) {
	call token_eek_char() if (rax == 'a') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 's') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'm') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = NASM
	rax = 1
	return
}

func token_next(0, 0) {
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'x') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 't') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = NEXT
	rax = 1
	return
}

func token_return(0, 0) {
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 't') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'u') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'r') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'n') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = RETURN
	rax = 1
	return
}

func token_switch(0, 0) {
	call token_eek_char() if (rax == 'w') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'i') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 't') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'c') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'h') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = SWITCH
	rax = 1
	return
}

func token_sys(0, 0) {
	call token_eek_char() if (rax == 'y') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 's') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = SYS
	rax = 1
	return
}

func token_ar(0, 0) {
	call token_eek_char() if (rax == 'a') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'r') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = VAR
	rax = 1
	return
}

func token_while(0, 0) {
	call token_eek_char() if (rax == 'h') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'i') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'l') { call token_kee_char() } else { rax = 0 return }
	call token_eek_char() if (rax == 'e') { call token_kee_char() } else { rax = 0 return }

	QWORD[token_tye] = WHILE
	rax = 1
	return
}

func token_number(0, 0) {
	loop {
		call token_eek_char()

		if (rax >= '0') {
			if (rax <= '9') {
				call token_kee_char()
				next
			}
		}

		break
	}

	QWORD[token_tye] = NUMBER
	rax = 1
	return
}

func token_identifier(0, 0) {
	loop {
		call token_eek_char()

		if (rax >= 'a') {
			if (rax <= 'z') {
				call token_kee_char()
				next
			}
		}

		if (rax >= 'A') {
			if (rax <= 'Z') {
				call token_kee_char()
				next
			}
		}

		if (rax >= '0') {
			if (rax <= '9') {
				call token_kee_char()
				next
			}
		}

		if (rax == '_') {
			call token_kee_char()
			next
		}

		break
	}

	QWORD[token_tye] = IDENTIFIER
	rax = 1
	return
}

func token_string(0, 0) {
	QWORD[token_length] = 0

	loop {
		call token_kee_char()

		if (rax == 0) {
			break
		}

		if (rax == 34) {
			break
		}

		if (rax == 92) {
			call token_kee_char()
		}
	}

	nasm("
		dec QWORD[token_length]
	")

	# Set NULL byte
	rax = QWORD[token_length]
	nasm("add rax, token_image")
	BYTE[rax] = 0

	QWORD[token_tye] = STRING
	rax = 1
	return
}

func token_comment(0, 0) {
	QWORD[token_length] = 0

	loop {
		call token_kee_char()

		if (rax == 0) {
			break
		}

		if (rax == '#') {
			break
		}

		if (rax == 10) {
			break
		}
	}

	nasm("
		dec QWORD[token_length]
	")

	QWORD[token_tye] = COMMENT
	rax = 1
	return
}

func token_character(0, 0) {
	call token_kee_char()

	if (rax == 92) {
		call token_kee_char()
	}

	call token_kee_char()

	if (rax == 39) {
		QWORD[token_tye] = CHARACTER
		rax = 1
	} else {
		rax = 0
	}

	return
}

# PRINTER
# TODO: Replace with string_print
func printer(3, 0) {
	if (arg3 == FILE) {
		rax = QWORD[out_file_fid]
		arg3 = rax
	}

	sys(1, arg3, arg2, arg1)
	return
}

func printer_line(1, 0) {
	call printer(arg1, on_line, 9)
	call printer_number(arg1, QWORD[line_number])
	call printer(arg1, column, 8)
	call printer_number(arg1, QWORD[column_number])
	return
}

func printer_stack(1, 2) {
	var1 = rbp
	loop {
		rax = var1
		nasm("add rax, 8")
		rax = QWORD[rax]
		var2 = rax

		if (var2 == 0) {
			break
		}

		call printer_number(arg1, var2)
		call printer(arg1, colon, 1)

		r13 = fun_list
		loop {
			# Load function address
			r14 = QWORD[r13]
			if (var2 > r14) {
				nasm("add r13, 8")
				r13 = QWORD[r13]
				call string_print(arg1, r13)
				break
			} else {
				nasm("add r13, 16")
			}
		}

		call printer(arg1, new_line, 1)

		# Load next rbp
		rax = var1
		rax = QWORD[rax]
		var1 = rax
	}
	return
}

func printer_number(2, 0) {
	# rax/arg1 - integer input
	# rcx - divisor
	# rdx - remainder
	# r12 - digit counter

	rax = arg1
	rcx = 10
	r12 = 0

	loop {
		rdx = 0
		nasm("
			div rcx
			push rdx
			inc r12
		")

		if (rax == 0) {
			break
		}
	}

	loop {
		nasm("
			pop rax
			add rax, '0'
		")

		BYTE[current_char] = al

		# Write byte to stdout
		call printer(arg2, current_char,1)

		nasm("
			dec r12
		")

		# Exit loop if count has reached 0
		if (r12 == 0) {
			break
		}
	}
	return
}

# MEMORY
func allocate(1, 1) {
	# arg1 - number of bytes to allocate

	sys(12, 0)
	var1 = rax
	rbx = arg1
	nasm("add rbx, rax")
	sys(12, rbx)

	rax = var1
	return
}

# STRING
func string_new(1,1) {
	# arg1 - size

	# Allocate memory
	rax = arg1
	nasm("add rax, 16
	")
	call allocate(rax)
	var1 = rax

	# Set length and size
	QWORD[rax] = 0
	nasm("add rax, 8")
	rbx = arg1
	QWORD[rax] = rbx

	rax = var1
	return
}

func string_length(1,0) {
	rax = arg1
	rax = QWORD[rax]
	return
}

func string_size(1,0) {
	rax = arg1
	nasm("add rax, 8")
	rax = QWORD[rax]
	return
}

func string_data(1,0) {
	rax = arg1
	nasm("add rax, 16")
	return
}

func string_append(2,0) {
	# arg2 - string
	# arg1 - character

	# TODO: check size is large enough

	rax = arg2
	rbx = QWORD[rax]
	nasm("inc QWORD[rax]
	add rax, 16
	add rax, rbx")
	rbx = arg1
	BYTE[rax] = bl

	return
}

func string_print(2,0) {
	if (arg2 == FILE) {
		rax = QWORD[out_file_fid]
		arg2 = rax
	}

	r12 = arg1
	r13 = QWORD[r12]
	nasm("add r12, 16")

	sys(1, arg2, r12, r13)
	return
}

func string_copy(2, 0) {
	# arg2 - source
	# arg1 - dest

	# Copy main data
	rsi = arg2
	rdi = arg1
	nasm("add rsi, 16
	add rdi, 16")
	rcx = arg2
	rcx = QWORD[rcx]
	nasm("rep movsb
	")

	# Set length of destination
	rax = arg2
	rax = QWORD[rax]
	rbx = arg1
	QWORD[rbx] = rax

	return
}

func string_clone(1, 1) {
	# arg1 - source

	call string_length(arg1)
	call string_new(rax)
	var1 = rax
	call string_copy(arg1, var1)
	rax = var1

	return
}

func string_clear(1, 0) {
	rax = arg1
	QWORD[rax] = 0
	return
}

func string_inspect(2, 0) {
	# arg2 - output stream
	# arg1 - string

	call printer_number(arg2, arg1)
	call printer(arg2, colon, 1)
	call string_length(arg1)
	call printer_number(arg2, rax)
	call printer(arg2, colon, 1)
	call string_size(arg1)
	call printer_number(arg2, rax)
	call printer(arg2, colon, 1)
	call string_print(arg2, arg1)
	call printer(arg2, new_line, 1)

	rax = arg1
	return
}

# ARRAY
func array_new(1,1) {
	# arg1 - size

	# Allocate memory
	rax = arg1
	nasm("shl rax, 3
	add rax, 16
	")
	call allocate(rax)
	var1 = rax

	# Set length and size
	QWORD[rax] = 0
	nasm("add rax, 8")
	rbx = arg1
	QWORD[rax] = rbx

	rax = var1
	return
}

func array_length(1,0) {
	rax = arg1
	rax = QWORD[rax]
	return
}

func array_size(1,0) {
	rax = arg1
	nasm("add rax, 8")
	rax = QWORD[rax]
	return
}

func array_append(2,0) {
	# arg2 - array
	# arg1 - item

	# TODO: check size is large enough

	rax = arg2
	rbx = QWORD[rax]
	nasm("add rax, 16
	shl rbx, 3
	add rax, rbx")
	rbx = arg1
	QWORD[rax] = rbx

	# Increment length
	rax = arg2
	nasm("inc QWORD[rax]")

	return
}

func array_get(2, 0) {
	# arg2 - array
	# arg1 - index

	rax = arg2
	rbx = arg1
	nasm("add rbx, 2
	shl rbx, 3
	add rax, rbx")
	rax = QWORD[rax]

	return
}
