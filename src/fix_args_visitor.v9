func fix_args(node)(children, sub_child, sub_node, new_name) {
	var children = node_children(var node)
	node_type(var node)

	if (rax == nFUNCTION) {
		var new_name = string_new(256)
		node_data(var node)

		# Leave main function alone
		string_equal(rax, "main")
		if (rax == 1) {
			fix_args_children(var children)
			return
		}

		node_data(var node)
		string_join(rax, var new_name)

		# Get arguments
		ll_get(var children, 0)
		node_parent(rax)
		node_children(rax)
		var sub_node = ll_first(rax)
		loop {
			if (var sub_node == 0) { break }
			var sub_child = lln_payload(var sub_node)

			string_append(var new_name, '_')
			node_class(var sub_child)
			node_data(rax)
			string_join(rax, var new_name)

			var sub_node = lln_next(var sub_node)
		}

		# Set new name
		var node[8] = var new_name

		fix_args_children(var children)
		return
	}

	if (rax == nCALL) {
		# Get name
		var new_name = string_new(256)
		ll_get(var children, 0)
		node_data(rax)

		# Occurs if a function pointer is stored in a variable
		if (rax == 0) {
			fix_args_children(var children)
			return
		}
		string_join(rax, var new_name)

		# Get arguments
		ll_get(var children, 1)
		node_children(rax)
		var sub_node = ll_first(rax)
		loop {
			if (var sub_node == 0) { break }
			var sub_child = lln_payload(var sub_node)

			string_append(var new_name, '_')
			node_class(var sub_child)
			if (rax == 0) {
				string_append(var new_name, '?')
			} else {
				node_data(rax)
				string_join(rax, var new_name)
			}

			var sub_node = lln_next(var sub_node)
		}

		# Set new name
		ll_get(var children, 0)
		rax[8] = var new_name

		fix_args_children(var children)
		return
	}

	fix_args_children(var children)

	return
}

func fix_args_children(children)(node) {
	var node = ll_first(var children)
	loop {
		if (var node == 0) {
			return
		}
		lln_payload(var node)
		fix_args(rax)
		var node = lln_next(var node)
	}

	return
}
