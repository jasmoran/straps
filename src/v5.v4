~
section .bss
	current_char:	resb	1
	ret_size:			resq	1
  loop_cnt:     resq  1
  if_cnt:       resq  1

section .data
	registers:		db		'rax,', 'rdi,', 'rsi,', 'rdx,', 'r10,', 'r8, '
	mov_inst:			db		10, 'mov '
	sys_inst:			db		10, 'syscall', 10
	func_prolog:	db		':', 10, 'push rbp', 10, 'mov rbp, rsp', 10, 'sub rsp, ' ;33
	func_post:		db		10, 'mov rsp, rbp', 10, 'pop rbp', 10, 'ret ' ;26
	new_line:			db		10
  loop_label:   db    '.loop_'
  loop_end_label: db    '.loop_end_'
  if_label:     db    '.if_'
  colon:        db    ':', 10
  jmp:          db    'jmp '
  jne:          db    'jne '
  cmp:          db    'cmp '
  push:         db    'push '
  call:         db    'call '
	comma:				db		', '
	param_ebp:		db		'QWORD[rbp + '
	var_ebp:			db		'QWORD[rbp - '
	square_close:	db		']'

section .text
global main
~

f asm_literal,0,0:
  l{
  	# Read byte from stdin
  	*0,0,current_char,1*

    # Check for EOF
    i rax, 0{
      b
    }i

    # Check for end NASM section
    i BYTE[current_char], 0x7E {
      b
    }i

  	# Write byte to stdout
  	*1,1,current_char,1*
  }l

	r


f syscall,0,0:
	~
		push 0

.print_mov:
~

	# Write move instruction to stdout
	*1,1,mov_inst,5*

~
	pop r9
	push r9
	shl r9, 2
	add r9, registers
~

	# Write register to stdout
	*1,1,r9,4*

~
	pop r9
	inc r9
	push r9
~

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for end of syscall
		i BYTE[current_char], 0x2A {
			b
		}i

		# Check for comma
		i BYTE[current_char], ',' {
			~
				jmp .print_mov
			~
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	# Write syscall instruction
	*1,1,sys_inst,9*

	~
		pop rax
	~
	r


f comment,0,0:
	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for hash
		i BYTE[current_char], '#' {
			b
		}i

		# Check for EOL
		i BYTE[current_char], 10 {
			b
		}i
	}l
	r


f read_number,0,0:
	~
		push 0
	~

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		~
			sub BYTE[current_char], '0'

			; Check for current_char < 0
			cmp BYTE[current_char], 0
			jl .ret

			; Check for current_char > 9
			cmp BYTE[current_char], 9
			jg .ret

			pop rax
			mov rcx, 10
			mul rcx

			add al, BYTE[current_char]

			push rax
		~
	}l

	~
		.ret:
			pop rax
	~
	r


f write_number,0,0:
	# rax - integer input
	# rcx - divisor
	# rdx - remainder
	# r12 - digit counter

	~
		mov rcx, 10
		xor r12, r12
	~

	l{
		~
			xor rdx, rdx
			div rcx
			push rdx
			inc r12
		~

		# Check for EOF
		i rax, 0 {
			b
		}i
	}l

	l{
		~
			pop rax
			add rax, '0'

			mov BYTE[current_char], al
		~

		# Write byte to stdout
		*1,1,current_char,1*

		~
			dec r12
		~

		# Exit loop if count has reached 0
		i r12, 0 {
			b
		}i
	}l
	r


f func_decl,0,0:

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for comma
		i BYTE[current_char], ',' {
		 b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	~
		call read_number
		shl rax, 3
		mov [ret_size], rax
	~

	# Write function prologue to stdout
	*1,1,func_prolog,33*

	~
		call read_number
		shl rax, 3
		call write_number
	~

	# Write new line to stdout
	*1,1,new_line,1*

	r


f func_ret,0,0:
	# Write function post to stdout
	*1,1,func_post,26*

	~
		mov rax, [ret_size]
		call write_number
	~

	# Write new line to stdout
	*1,1,new_line,1*

	r


f loop_start,0,0:
  # Read '{' from stdin
  *0,0,current_char,1*

  # Write new line to stdout
  *1,1,new_line,1*

  # Write label to stdout
  *1,1,loop_label,6*

	~
	  mov rax, [loop_cnt]
	  call write_number
	~

  # Write colon to stdout
  *1,1,colon,2*

  r


f if_start,0,0:
  # Write new line to stdout
  *1,1,new_line,1*

  # Write cmp to stdout
  *1,1,cmp,4*

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for '{'
		i BYTE[current_char], 123 {
			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

  # Write new line to stdout
  *1,1,new_line,1*

  # Write jne to stdout
  *1,1,jne,4*

  # Write if label to stdout
  *1,1,if_label,4*

	~
	  mov rax, [if_cnt]
	  call write_number
	~

  # Write new line to stdout
  *1,1,new_line,1*
  r


f loop_next,0,0:
  # Write jump to stdout
  *1,1,jmp,4*

  # Write loop label to stdout
  *1,1,loop_label,6*

	~
	  mov rax, [loop_cnt]
	  call write_number
	~

  # Write new line to stdout
  *1,1,new_line,1*
  r


f loop_end,0,0:
	~
	  call loop_next
	~

  # Write loop end label to stdout
  *1,1,loop_end_label,10*

	~
	  mov rax, [loop_cnt]
	  call write_number
	  inc QWORD[loop_cnt]
	~

  # Write colon to stdout
  *1,1,colon,2*

  # Write new line to stdout
  *1,1,new_line,1*
  r

f if_end,0,0:
  # Write if label to stdout
  *1,1,if_label,4*

	~
	  mov rax, [if_cnt]
	  call write_number
	  inc QWORD[if_cnt]
	~

  # Write colon to stdout
  *1,1,colon,2*
  r


f loop_break,0,0:
  # Write jump to stdout
  *1,1,jmp,4*

  # Write loop label to stdout
  *1,1,loop_end_label,10*

	~
	  mov rax, [loop_cnt]
	  call write_number
	~

  # Write new line to stdout
  *1,1,new_line,1*
  r


f block_end,0,0:
  # Read block type from stdin
  *0,0,current_char,1*

  # If block
  i BYTE[current_char], 'i' {
		~
    	call if_end
		~
  }i

  # Loop block
  i BYTE[current_char], 'l' {
		~
			call loop_end
		~
	}i

  r


f function_call,0,0:
	# Read byte from stdin
	*0,0,current_char,1*

	~
		cmp BYTE[current_char], ')'
		je .first_iter
	~

	# Write push to stdout
	*1,1,push,5*

	~
		jmp .first_iter
	~

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		~
			.first_iter:
		~

		# Check for EOF
		i rax, 0 {
		b
		}i

		# Check for comma
		i BYTE[current_char], ',' {
			# Write new line to stdout
			*1,1,new_line,1*

			# Write push to stdout
			*1,1,push,5*

			n
		}i

		# Check for close bracket
		i BYTE[current_char], ')' {
			# Write new line to stdout
			*1,1,new_line,1*

			# Write call to stdout
			*1,1,call,5*

			n
		}i

		# Check for parameter
		i BYTE[current_char], 'p' {
			~
				call parameter
			~
			n
		}i

		# Check for parameter
		i BYTE[current_char], 'v' {
			~
				call variable
			~
			n
		}i

		# Check for semicolon
		i BYTE[current_char], ';' {
			# Write new line to stdout
			*1,1,new_line,1*

			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	r


f parameter,0,0:
	# Print 'QWORD[rbp + ' to stdout
	*1,1,param_ebp,12*

	~
		call read_number
		inc rax
		shl rax, 3
		call write_number
	~

	# Print square close bracket
	*1,1,square_close,1*

	r


f variable,0,0:
	# Print 'QWORD[rbp - ' to stdout
	*1,1,var_ebp,12*

	~
		call read_number
		shl rax, 3
		call write_number
	~

	# Print square close bracket
	*1,1,square_close,1*

	r


f assignment,0,0:
	# Print mov instruction to stdout
	*1,1,mov_inst,5*

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for equals
		i BYTE[current_char], '=' {
			# Write comma to stdout
			*1,1,comma,2*
			n
		}i

		# Check for parameter
		i BYTE[current_char], 'p' {
			~
				call parameter
			~
			n
		}i

		# Check for variable
		i BYTE[current_char], 'v' {
			~
				call variable
			~
			n
		}i

		# Check for semicolon
		i BYTE[current_char], ';' {
			# Write new line to stdout
			*1,1,new_line,1*

			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	r



f main,0,0:
	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for NASM section
		i BYTE[current_char], 0x7E {
			~
				call asm_literal
			~
			n
		}i

		# Check for syscall
		i BYTE[current_char], 0x2A {
			~
				call syscall
			~
			n
		}i

		# Check for comment
		i BYTE[current_char], '#' {
			~
				call comment
			~
			n
		}i

		# Check for function declaration
		i BYTE[current_char], 'f' {
			~
				call func_decl
			~
			n
		}i

		# Check for function return
		i BYTE[current_char], 'r' {
			~
				call func_ret
			~
			n
		}i

	  # Check for loop declaration
	  i BYTE[current_char], 'l' {
	  	~
	    	call loop_start
			~
	    n
	  }i

	  # Check for if declaration
	  i BYTE[current_char], 'i' {
	  	~
	    	call if_start
			~
	    n
	  }i

	  # Check for next call
	  i BYTE[current_char], 'n' {
	  	~
	    	call loop_next
			~
	    n
	  }i

	  # Check for break call
	  i BYTE[current_char], 'b' {
	  	~
	    	call loop_break
			~
	    n
	  }i

	  # Check for end of block
	  i BYTE[current_char], '}' {
	  	~
	    	call block_end
			~
	    n
	  }i

		# Check function call
	  i BYTE[current_char], '(' {
	  	~
	    	call function_call
			~
	    n
	  }i

		# Check for assignment
		i BYTE[current_char], 'a' {
			~
				call assignment
			~
			n
		}i

		# Check for parameter
		i BYTE[current_char], 'p' {
			~
				call parameter
			~
			n
		}i

		# Check for variable
		i BYTE[current_char], 'v' {
			~
				call variable
			~
			n
		}i

	}l

	~
	  mov rsp, rbp
	  pop rbp
	~
