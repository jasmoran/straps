func index_call(node)(children, new, new_child, sub_child) {
	var children = node_children(var node)
	node_type(var node)

	if (rax == nCALL) {
		ll_get(var children, 0)
		index_call(rax)

		ll_get(var children, 1)
		node_children(rax)
		var sub_child = ll_last(rax)
		loop {
			if (var sub_child == 0) {
				break
			}
			var new_child = lln_payload(var sub_child)
			index_call(var new_child)

			var new = node_new(nPUSH, 0, 0)
			node_children(var new)
			ll_append(rax, var new_child)

			index_call_prepend(var node, var new)

			var sub_child = lln_prev(var sub_child)
		}

		var new = node_new(nCALL, 0, 0)
		var new_child = ll_get(var children, 0)
		node_children(var new)
		ll_append(rax, var new_child)
		index_call_prepend(var node, var new)

		node_parent(var node)
		node_type(rax)
		if (rax == nSTATEMENTS) {
			var node[0] = nNONE
		} else {
			var node[0] = nREGISTER
			var node[8] = "rax"
		}

		ll_remove(var children, 0)
		ll_remove(var children, 1)

		return
	}

	if (rax == nCOMPARISON) {
		ll_get(var children, 0)
		index_call(rax)

		scratch_reg[0] = "r13"
		var new_child = ll_get(var children, 1)
		index_call(rax)

		node_type(var new_child)
		if (rax == nMEM_ACCESS) {
			var new = node_new(nOPERATION, 0, 0)
			var new[8] = ASSIGN

			node_children(var new)
			ll_append(rax, var new_child)

			var new_child = node_new(nREGISTER, 4, var new)
			node_data(var new_child)
			string_copy(scratch_reg[0], rax)
			node_children(var new)
			ll_prepend(rax, var new_child)

			index_call_prepend(var node, var new)

			ll_set(var children, 1, var new_child)
		}

		scratch_reg[0] = "r12"

		return
	}

	if (rax == nINDEX) {
		var new_child = ll_get(var children, 0)
		index_call(rax)

		var node[0] = nMEM_ACCESS
		ll_get(var children, 1)
		node_data(rax)
		string_prepend(rax, '+')

		node_type(var new_child)
		if (rax == nMEM_ACCESS) {
			var new = node_new(nOPERATION, 0, 0)
			var new[8] = ASSIGN

			node_children(var new)
			ll_append(rax, var new_child)

			var new_child = node_new(nREGISTER, 4, var new)
			node_data(var new_child)
			string_copy(scratch_reg[0], rax)
			node_children(var new)
			ll_prepend(rax, var new_child)

			index_call_prepend(var node, var new)

			ll_set(var children, 0, var new_child)
		}

		return
	}

	if (rax == nOPERATION) {
		ll_get(var children, 0)
		index_call(rax)

		ll_length(var children)
		if (rax == 2) {
			scratch_reg[0] = "r13"
			var new_child = ll_get(var children, 1)
			index_call(rax)

			node_type(var new_child)
			if (rax == nMEM_ACCESS) {
				var new = node_new(nOPERATION, 0, 0)
				var new[8] = ASSIGN

				node_children(var new)
				ll_append(rax, var new_child)

				var new_child = node_new(nREGISTER, 4, var new)
				node_data(var new_child)
				string_copy(scratch_reg[0], rax)
				node_children(var new)
				ll_prepend(rax, var new_child)

				index_call_prepend(var node, var new)

				ll_set(var children, 1, var new_child)
			}
			scratch_reg[0] = "r12"
		}

		return
	}

	index_call_children(var children)

	return
}

func index_call_prepend(new, child)(parent, list) {
	var parent = var child
	loop {
		if (var parent == 0) {
			string_print(STDERR, "Error: Could not find enclosing nSTATEMENTS")
			string_print(STDERR, new_line)
			sys(60,1)
		}

		node_type(var parent)
		if (rax == nSTATEMENTS) {
			break
		}

		var child = var parent
		var parent = node_parent(var parent)
	}

	var list = node_children(var parent)
	ll_fetch_by_data(var list, var child)
	ll_insert_before(var list, rax, var new)

	return
}

func index_call_move()() {
	return
}

func index_call_children(children)(node) {
	var node = ll_first(var children)
	loop {
		if (var node == 0) {
			break
		}
		lln_payload(var node)
		index_call(rax)
		var node = lln_next(var node)
	}

	return
}
