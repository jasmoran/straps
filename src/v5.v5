~
section .bss
	current_char:	resb	1
	ret_size:			resq	1
  loop_cnt:     resq  1
  if_cnt:       resq  1

section .data
	registers:		db		'rax,', 'rdi,', 'rsi,', 'rdx,', 'r10,', 'r8, '
	mov_inst:			db		10, 'mov '
	sys_inst:			db		10, 'syscall', 10
	func_prolog:	db		':', 10, 'push rbp', 10, 'mov rbp, rsp', 10, 'sub rsp, ' ;33
	func_post:		db		10, 'mov rsp, rbp', 10, 'pop rbp', 10, 'ret ' ;26
	new_line:			db		10
  loop_label:   db    '.loop_'
  loop_end_label: db    '.loop_end_'
  if_label:     db    '.if_'
  colon:        db    ':', 10
  jmp:          db    'jmp '
  jne:          db    'jne '
  cmp:          db    'cmp '
  push:         db    'push '
  call:         db    'call '
	comma:				db		', '
	param_ebp:		db		'QWORD[rbp + '
	var_ebp:			db		'QWORD[rbp - '
	square_close:	db		']'

section .text
global main
~

f asm_literal,0,0:
  l{
  	# Read byte from stdin
  	*0,0,current_char,1*

    # Check for EOF
    i rax, 0{
      b
    }i

    # Check for end NASM section
    i BYTE[current_char], 0x7E {
      b
    }i

  	# Write byte to stdout
  	*1,1,current_char,1*
  }l

	r


f syscall,0,1:
	a v1 =0;

	~
	.print_mov:
	~

	# Write move instruction to stdout
	*1,1,mov_inst,5*

	a r9=v1 ;
	~
		shl r9, 2
		add r9, registers
	~

	# Write register to stdout
	*1,1,r9,4*

	~inc ~v1

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for end of syscall
		i BYTE[current_char], 0x2A {
			b
		}i

		# Check for comma
		i BYTE[current_char], ',' {
			~
				jmp .print_mov
			~
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	# Write syscall instruction
	*1,1,sys_inst,9*

	r


f comment,0,0:
	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for hash
		i BYTE[current_char], '#' {
			b
		}i

		# Check for EOL
		i BYTE[current_char], 10 {
			b
		}i
	}l
	r


f read_number,0,1:
	a v1 =0;

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		~
			sub BYTE[current_char], '0'

			; Check for current_char < 0
			cmp BYTE[current_char], 0
			jl .ret

			; Check for current_char > 9
			cmp BYTE[current_char], 9
			jg .ret

		~
		a rax=v1 ;
		a rcx=10;
		~
			mul rcx
			add al, BYTE[current_char]
		~
		a v1 =rax;
	}l

	~
		.ret:
	~
	r


f write_number,1,0:
	# rax/p1 - integer input
	# rcx - divisor
	# rdx - remainder
	# r12 - digit counter

	a rax=p1 ;
	a rcx=10;
	a r12=0;

	l{
		a rdx=0;
		~
			div rcx
			push rdx
			inc r12
		~

		# Check for EOF
		i rax, 0 {
			b
		}i
	}l

	l{
		~
			pop rax
			add rax, '0'
		~

		a BYTE[current_char]=al;

		# Write byte to stdout
		*1,1,current_char,1*

		~
			dec r12
		~

		# Exit loop if count has reached 0
		i r12, 0 {
			b
		}i
	}l
	r


f func_decl,0,0:
	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for comma
		i BYTE[current_char], ',' {
			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	()read_number;
	~
		shl rax, 3
	~
	a [ret_size]=rax;

	# Write function prologue to stdout
	*1,1,func_prolog,33*

	()read_number;
	~
		shl rax, 3
	~
	(rax)write_number;

	# Write new line to stdout
	*1,1,new_line,1*

	r


f func_ret,0,0:
	# Write function post to stdout
	*1,1,func_post,26*

	(QWORD[ret_size])write_number;

	# Write new line to stdout
	*1,1,new_line,1*

	r


f loo_start,0,0:
  # Read '{' from stdin
  *0,0,current_char,1*

  # Write new line to stdout
  *1,1,new_line,1*

  # Write label to stdout
  *1,1,loop_label,6*

	(QWORD[loop_cnt])write_number;

  # Write colon to stdout
  *1,1,colon,2*

  r


f if_start,0,0:
  # Write new line to stdout
  *1,1,new_line,1*

  # Write cmp to stdout
  *1,1,cmp,4*

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for '{'
		i BYTE[current_char], 123 {
			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

  # Write new line to stdout
  *1,1,new_line,1*

  # Write jne to stdout
  *1,1,jne,4*

  # Write if label to stdout
  *1,1,if_label,4*

	(QWORD[if_cnt])write_number;

  # Write new line to stdout
  *1,1,new_line,1*
  r


f loo_next,0,0:
  # Write jump to stdout
  *1,1,jmp,4*

  # Write loop label to stdout
  *1,1,loop_label,6*

	(QWORD[loop_cnt])write_number;

  # Write new line to stdout
  *1,1,new_line,1*
  r


f loo_end,0,0:
	()loo_next;

  # Write loop end label to stdout
  *1,1,loop_end_label,10*

	(QWORD[loop_cnt])write_number;
	~
	  inc QWORD[loop_cnt]
	~

  # Write colon to stdout
  *1,1,colon,2*

  # Write new line to stdout
  *1,1,new_line,1*
  r

f if_end,0,0:
  # Write if label to stdout
  *1,1,if_label,4*

	(QWORD[if_cnt])write_number;
	~
	  inc QWORD[if_cnt]
	~

  # Write colon to stdout
  *1,1,colon,2*
  r


f loo_break,0,0:
  # Write jump to stdout
  *1,1,jmp,4*

  # Write loop label to stdout
  *1,1,loop_end_label,10*

	(QWORD[loop_cnt])write_number;

  # Write new line to stdout
  *1,1,new_line,1*
  r


f block_end,0,0:
  # Read block type from stdin
  *0,0,current_char,1*

  # If block
  i BYTE[current_char], 'i' {
		()if_end;
  }i

  # Loop block
  i BYTE[current_char], 'l' {
		()loo_end;
	}i

  r


f function_call,0,0:
	# Read byte from stdin
	*0,0,current_char,1*

	~
		cmp BYTE[current_char], ')'
		je .first_iter
	~

	# Write push to stdout
	*1,1,push,5*

	~
		jmp .first_iter
	~

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		~
			.first_iter:
		~

		# Check for EOF
		i rax, 0 {
		b
		}i

		# Check for comma
		i BYTE[current_char], ',' {
			# Write new line to stdout
			*1,1,new_line,1*

			# Write push to stdout
			*1,1,push,5*

			n
		}i

		# Check for close bracket
		i BYTE[current_char], ')' {
			# Write new line to stdout
			*1,1,new_line,1*

			# Write call to stdout
			*1,1,call,5*

			n
		}i

		# Check for parameter
		i BYTE[current_char], 'p' {
			()arameter;
			n
		}i

		# Check for variable
		i BYTE[current_char], 'v' {
			()ariable;
			n
		}i

		# Check for semicolon
		i BYTE[current_char], ';' {
			# Write new line to stdout
			*1,1,new_line,1*

			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	r


f arameter,0,0:
	# Print 'QWORD[rbp + ' to stdout
	*1,1,param_ebp,12*

	()read_number;
	~
		inc rax
		shl rax, 3
	~
	(rax)write_number;

	# Print square close bracket
	*1,1,square_close,1*

	r


f ariable,0,0:
	# Print 'QWORD[rbp - ' to stdout
	*1,1,var_ebp,12*

	()read_number;
	~
		shl rax, 3
	~
	(rax)write_number;

	# Print square close bracket
	*1,1,square_close,1*

	r


f assignment,0,0:
	# Print mov instruction to stdout
	*1,1,mov_inst,5*

	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for equals
		i BYTE[current_char], '=' {
			# Write comma to stdout
			*1,1,comma,2*
			n
		}i

		# Check for parameter
		i BYTE[current_char], 'p' {
			()arameter;
			n
		}i

		# Check for variable
		i BYTE[current_char], 'v' {
			()ariable;
			n
		}i

		# Check for semicolon
		i BYTE[current_char], ';' {
			# Write new line to stdout
			*1,1,new_line,1*

			b
		}i

		# Write byte to stdout
		*1,1,current_char,1*
	}l

	r



f main,0,0:
	l{
		# Read byte from stdin
		*0,0,current_char,1*

		# Check for EOF
		i rax, 0 {
			b
		}i

		# Check for NASM section
		i BYTE[current_char], 0x7E {
			()asm_literal;
			n
		}i

		# Check for syscall
		i BYTE[current_char], 0x2A {
			()syscall;
			n
		}i

		# Check for comment
		i BYTE[current_char], '#' {
			()comment;
			n
		}i

		# Check for function declaration
		i BYTE[current_char], 'f' {
			()func_decl;
			n
		}i

		# Check for function return
		i BYTE[current_char], 'r' {
			()func_ret;
			n
		}i

	  # Check for loop declaration
	  i BYTE[current_char], 'l' {
	  	()loo_start;
	    n
	  }i

	  # Check for if declaration
	  i BYTE[current_char], 'i' {
	  	()if_start;
	    n
	  }i

	  # Check for next call
	  i BYTE[current_char], 'n' {
	  	()loo_next;
	    n
	  }i

	  # Check for break call
	  i BYTE[current_char], 'b' {
	  	()loo_break;
	    n
	  }i

	  # Check for end of block
	  i BYTE[current_char], '}' {
	  	()block_end;
	    n
	  }i

		# Check function call
	  i BYTE[current_char], '(' {
	  	()function_call;
	    n
	  }i

		# Check for assignment
		i BYTE[current_char], 'a' {
			()assignment;
			n
		}i

		# Check for parameter
		i BYTE[current_char], 'p' {
			()arameter;
			n
		}i

		# Check for variable
		i BYTE[current_char], 'v' {
			()ariable;
			n
		}i

	}l

	~
		mov rsp, rbp
	  pop rbp
	~
